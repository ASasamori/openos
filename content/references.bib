---
---

@book{arpaci2018operating,
  title={Operating systems: Three easy pieces},
  author={Arpaci-Dusseau, Remzi H and Arpaci-Dusseau, Andrea C},
  url = {https://pages.cs.wisc.edu/~remzi/OSTEP/},
  year={2018},
  publisher={Arpaci-Dusseau Books LLC Boston}
}

@article{10.1145/1288783.1288788,
author = {Agrawal, Nitin and Bolosky, William J. and Douceur, John R. and Lorch, Jacob R.},
title = {A Five-Year Study of File-System Metadata},
year = {2007},
issue_date = {October 2007},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {3},
number = {3},
issn = {1553-3077},
url = {https://doi.org/10.1145/1288783.1288788},
doi = {10.1145/1288783.1288788},
abstract = {For five years, we collected annual snapshots of file-system metadata from over 60,000 Windows PC file systems in a large corporation. In this article, we use these snapshots to study temporal changes in file size, file age, file-type frequency, directory size, namespace structure, file-system population, storage capacity and consumption, and degree of file modification. We present a generative model that explains the namespace structure and the distribution of directory sizes. We find significant temporal trends relating to the popularity of certain file types, the origin of file content, the way the namespace is used, and the degree of variation among file systems, as well as more pedestrian changes in size and capacities. We give examples of consequent lessons for designers of file systems and related software.},
journal = {ACM Trans. Storage},
month = {oct},
pages = {9–es},
numpages = {32},
keywords = {File systems, generative model, longitudinal study}
}

@techreport{10.5555/1102034,
author = {Dijkstra, Edsger Wybe},
title = {Cooperating Sequential Processes, Technical Report EWD-123},
year = {1965}
}

@article{Peterson1981,
  title={Myths About the Mutual Exclusion Problem},
  author={Gary L. Peterson},
  journal={Information Processing Letters},
  year={1981},
  volume={12},
  pages={115-116}
}

@Inbook{Schneider1997,
author="Schneider, Fred B.",
bookTitle="On Concurrent Programming",
year="1997",
publisher="Springer New York NY",
isbn="978-0-387-94942-0",
doi="10.1007/978-1-4612-1830-2",
}

@article{10.1145/103727.103729,
author = {Mellor-Crummey, John M. and Scott, Michael L.},
title = {Algorithms for Scalable Synchronization on Shared-Memory Multiprocessors},
year = {1991},
issue_date = {Feb. 1991},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {9},
number = {1},
issn = {0734-2071},
url = {https://doi.org/10.1145/103727.103729},
doi = {10.1145/103727.103729},
abstract = {Busy-wait techniques are heavily used for mutual exclusion and barrier synchronization in shared-memory parallel programs. Unfortunately, typical implementations of busy-waiting tend to produce large amounts of memory and interconnect contention, introducing performance bottlenecks that become markedly more pronounced as applications scale. We argue that this problem is not fundamental, and that one can in fact construct busy-wait synchronization algorithms that induce no memory or interconnect contention. The key to these algorithms is for every processor to spin on separate locally-accessible flag variables, and for some other processor to terminate the spin with a single remote write operation at an appropriate time. Flag variables may be locally-accessible as a result of coherent caching, or by virtue of allocation in the local portion of physically distributed shared memory.We present a new scalable algorithm for spin locks that generates 0(1) remote references per lock acquisition, independent of the number of processors attempting to acquire the lock. Our algorithm provides reasonable latency in the absence of contention, requires only a constant amount of space per lock, and requires no hardware support other than a swap-with-memory instruction. We also present a new scalable barrier algorithm that generates 0(1) remote references per processor reaching the barrier, and observe that two previously-known barriers can likewise be cast in a form that spins only on locally-accessible flag variables. None of these barrier algorithms requires hardware support beyond the usual atomicity of memory reads and writes.We compare the performance of our scalable algorithms with other software approaches to busy-wait synchronization on both a Sequent Symmetry and a BBN Butterfly. Our principal conclusion is that contention due to synchronization need not be a problem in large-scale shared-memory multiprocessors. The existence of scalable algorithms greatly weakens the case for costly special-purpose hardware support for synchronization, and provides a case against so-called “dance hall” architectures, in which shared memory locations are equally far from all processors. —From the Authors' Abstract},
journal = {ACM Trans. Comput. Syst.},
month = {feb},
pages = {21–65},
numpages = {45}
}

@article{10.1145/361082.361093,
author = {Lamport, Leslie},
title = {A New Solution of Dijkstra's Concurrent Programming Problem},
year = {1974},
issue_date = {Aug. 1974},
publisher = {Association for Computing Machinery},
address = {New York, NY, USA},
volume = {17},
number = {8},
issn = {0001-0782},
url = {https://doi.org/10.1145/361082.361093},
doi = {10.1145/361082.361093},
abstract = {A simple solution to the mutual exclusion problem is presented which allows the system to continue to operate despite the failure of any individual component.},
journal = {Commun. ACM},
month = {aug},
pages = {453–455},
numpages = {3},
keywords = {concurrent programming, semaphores, multiprocessing, critical section}
}
