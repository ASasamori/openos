
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>7. Other stuff from peter to integrate &#8212; Introduction to Operating Systems</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" href="../_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script async="async" kind="hypothesis" src="https://hypothes.is/embed.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.20.1/dist/embed-amd.js"></script>
    <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="10. Processor Scheduling" href="../scheduling/scheduling.html" />
    <link rel="prev" title="6. Tools" href="tools.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../_static/logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">Introduction to Operating Systems</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="pref.html">
                    Preface
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Getting started
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="intro.html">
   1. Introduction
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="purpose.html">
   2. Purpose of operating systems
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="structure.html">
   3. Operating System Structure &amp; Unix/Linux
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="services.html">
   4. Operating System Services
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="tools.html">
   6. Tools
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   7. Other stuff from peter to integrate
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Scheduling
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../scheduling/scheduling.html">
   10. Processor Scheduling
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Memory Management
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../mm/intro.html">
   11. Introduction
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../mm/physmem.html">
   12. Memory management without translation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../mm/virt-seg.html">
   13. Segmentation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../mm/virt-paging.html">
   14. Paging
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../mm/page-tables.html">
   15. Page Tables
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../mm/reclamation.html">
   16. Memory reclaiming algorithms.
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../mm/buffer-cache.html">
   17. Page Sizes
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../mm/pagefaults.html">
   18. Page Faults
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../mm/misc.html">
   19. Conclusion
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../mm/realworld.html">
   20. Memory management in the real world
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../mm/concl.html">
   21. Other Stuff
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../mm/mm.html">
   22. EVERYTHING BELOW HERE IS CRAP
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../mm/Overview.html">
   24. Overview of MM
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../mm/peter-mm.html">
   25. Peter’s Virtual Memory chapter
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  File Systems
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../fs/intro.html">
   26. Introduction
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../fs/interface.html">
   27. Interface
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../fs/disklayout.html">
   28. File System Layout
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../fs/kernelimp.html">
   29. Kernel implementation
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Concurrency
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../sync/sync.html">
   30. Intro Concurrency Synchronization and Deadlock
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../sync/sharing.html">
   31. Cooperating Processes
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../sync/locking.html">
   32. Synchronization Primitives
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../sync/deadlock.html">
   33. Deadlocks
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../sync/hardware_challenges.html">
   34. Challenges of Modern Hardware
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../sync/linux_locking.html">
   35. Locking in the Linux Kernel
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../sync/peter-syncro.html">
   36. Synchronization – Safety &amp; Sequencing - FROM PETER’s BOOK
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Other Topics
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../misc/OtherInro.html">
   37. Overview of other topics
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../sec/sec.html">
   38. Security
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../virt/virt.html">
   40. Virtualization and Cloud computing
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="other.html">
   42. Other OS structures
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../devices/block-dev.html">
   43. I/O, Drivers, and DMA {#chap:blockdevs}
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Appendices
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../contributing/Contributing.html">
   44. Contributing
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../misc/bib.html">
   45. Bibliography
  </a>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<div class="menu-dropdown menu-dropdown-launch-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Launch interactive content">
      <i class="fas fa-rocket"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://mybinder.org/v2/gh/okrieg/openos/main?urlpath=lab/tree/content/intro/peter-other.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Launch on Binder"
>
  

<span class="headerbtn__icon-container">
  
    <img src="../_static/images/logo_binder.svg">
  </span>
<span class="headerbtn__text-container">Binder</span>
</a>

      </li>
      
      <li>
        <a href="https://jupyterhub-redhat-ods-applications.apps.buaws-dev.idu6.p1.openshiftapps.com/hub/user-redirect/git-pull?repo=https%3A//github.com/okrieg/openos&urlpath=lab/tree/openos/content/intro/peter-other.ipynb&branch=main"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Launch on JupyterHub"
>
  

<span class="headerbtn__icon-container">
  
    <img src="../_static/images/logo_jupyterhub.svg">
  </span>
<span class="headerbtn__text-container">JupyterHub</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>

<div class="menu-dropdown menu-dropdown-repository-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Source repositories">
      <i class="fab fa-github"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://github.com/okrieg/openos"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Source repository"
>
  

<span class="headerbtn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="headerbtn__text-container">repository</span>
</a>

      </li>
      
      <li>
        <a href="https://github.com/okrieg/openos/issues/new?title=Issue%20on%20page%20%2Fintro/peter-other.html&body=Your%20issue%20content%20here."
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Open an issue"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="headerbtn__text-container">open issue</span>
</a>

      </li>
      
      <li>
        <a href="https://github.com/okrieg/openos/edit/main/content/intro/peter-other.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Edit this page"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-pencil-alt"></i>
  </span>
<span class="headerbtn__text-container">suggest edit</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

<div class="menu-dropdown menu-dropdown-download-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Download this page">
      <i class="fas fa-download"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="../_sources/intro/peter-other.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Download source file"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="headerbtn__text-container">.ipynb</span>
</a>

      </li>
      
      <li>
        
<button onclick="printPdf(this)"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="left"
title="Print to PDF"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="headerbtn__text-container">.pdf</span>
</button>

      </li>
      
    </ul>
  </div>
</div>
<label for="__page-toc"
  class="headerbtn headerbtn-page-toc"
  
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-list"></i>
  </span>

</label>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
    <div class="tocsection onthispage pt-5 pb-3">
        <i class="fas fa-list"></i> Contents
    </div>
    <nav id="bd-toc-nav" aria-label="Page">
        <ul class="visible nav section-nav flex-column">
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#">
   7. Other stuff from peter to integrate
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#from-intro">
     7.1. from Intro
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#introduction">
   8. Introduction
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#peter">
     8.1. Peter
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#program-and-os-organization-chap-osbasics">
   9. Program and OS Organization {#chap:osbasics}
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#a-simple-computer">
     9.1. A Simple Computer
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#review-questions">
       9.1.1. Review Questions
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#program-organization">
     9.2. Program Organization
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#a-simple-operating-system-interface">
     9.3. A Simple Operating System Interface
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#program-loading">
     9.4. Program Loading
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#id7">
       9.4.1. Review Questions
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#comparison-to-ms-dos-1-0">
       9.4.2. Comparison to MS-DOS 1.0
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#device-virtualization">
     9.5. Device Virtualization
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#address-space-and-program-loading">
     9.6. Address Space and Program Loading
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#interrupts">
     9.7. Interrupts
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#id10">
       9.7.1. Review Questions
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#context-switching">
     9.8. Context Switching
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#id12">
       9.8.1. Review Questions
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#advanced-context-switching">
     9.9. Advanced Context Switching
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#scheduling">
       9.9.1. Scheduling
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#multi-user-computer-system">
       9.9.2. Multi-User Computer System
      </a>
      <ul class="nav section-nav flex-column">
       <li class="toc-h4 nav-item toc-entry">
        <a class="reference internal nav-link" href="#id15">
         9.9.2.1. Review Questions
        </a>
       </li>
      </ul>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#i-o-driven-context-switching">
       9.9.3. I/O-driven Context Switching
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#address-spaces-for-multiple-processes">
     9.10. Address Spaces for Multiple Processes
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#memory-protection-and-translation">
     9.11. Memory Protection and Translation
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#putting-it-all-together">
     9.12. Putting it all together
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#answers-to-review-questions">
       9.12.1. Answers to Review Questions
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>

    </nav>
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Other stuff from peter to integrate</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#">
   7. Other stuff from peter to integrate
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#from-intro">
     7.1. from Intro
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#introduction">
   8. Introduction
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#peter">
     8.1. Peter
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h1 nav-item toc-entry">
  <a class="reference internal nav-link" href="#program-and-os-organization-chap-osbasics">
   9. Program and OS Organization {#chap:osbasics}
  </a>
  <ul class="visible nav section-nav flex-column">
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#a-simple-computer">
     9.1. A Simple Computer
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#review-questions">
       9.1.1. Review Questions
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#program-organization">
     9.2. Program Organization
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#a-simple-operating-system-interface">
     9.3. A Simple Operating System Interface
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#program-loading">
     9.4. Program Loading
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#id7">
       9.4.1. Review Questions
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#comparison-to-ms-dos-1-0">
       9.4.2. Comparison to MS-DOS 1.0
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#device-virtualization">
     9.5. Device Virtualization
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#address-space-and-program-loading">
     9.6. Address Space and Program Loading
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#interrupts">
     9.7. Interrupts
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#id10">
       9.7.1. Review Questions
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#context-switching">
     9.8. Context Switching
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#id12">
       9.8.1. Review Questions
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#advanced-context-switching">
     9.9. Advanced Context Switching
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#scheduling">
       9.9.1. Scheduling
      </a>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#multi-user-computer-system">
       9.9.2. Multi-User Computer System
      </a>
      <ul class="nav section-nav flex-column">
       <li class="toc-h4 nav-item toc-entry">
        <a class="reference internal nav-link" href="#id15">
         9.9.2.1. Review Questions
        </a>
       </li>
      </ul>
     </li>
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#i-o-driven-context-switching">
       9.9.3. I/O-driven Context Switching
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#address-spaces-for-multiple-processes">
     9.10. Address Spaces for Multiple Processes
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#memory-protection-and-translation">
     9.11. Memory Protection and Translation
    </a>
   </li>
   <li class="toc-h2 nav-item toc-entry">
    <a class="reference internal nav-link" href="#putting-it-all-together">
     9.12. Putting it all together
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h3 nav-item toc-entry">
      <a class="reference internal nav-link" href="#answers-to-review-questions">
       9.12.1. Answers to Review Questions
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <section class="tex2jax_ignore mathjax_ignore" id="other-stuff-from-peter-to-integrate">
<h1><span class="section-number">7. </span>Other stuff from peter to integrate<a class="headerlink" href="#other-stuff-from-peter-to-integrate" title="Permalink to this headline">#</a></h1>
<section id="from-intro">
<h2><span class="section-number">7.1. </span>from Intro<a class="headerlink" href="#from-intro" title="Permalink to this headline">#</a></h2>
</section>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="introduction">
<h1><span class="section-number">8. </span>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">#</a></h1>
<p>This textbook is for the CS5600 class in the Northeastern College of
Computer and Information Science, based on the design of CS5600 starting
in Fall of 2008. The goal of this class is not to teach you how to write
an operating system—that is an obscure skill, practiced by far fewer
people than you might think. Nor is it to learn how to use an operating
system—depending on the type of use, that would be system
administration, programming, or just using a computer. Instead the goal
is to teach you how computers work, by describing the interacting parts
underneath the user and programming interfaces.</p>
<p><img alt="Linux text console with simplecommand." src="../_images/intro-screenshot.png" />{#ch1:fig:console width=”80%”}</p>
<p>For an example of what this means, consider running a simple command
such as <code class="docutils literal notranslate"><span class="pre">ls</span></code> on a Linux system. In
<a class="reference external" href="#ch1:fig:console">[ch1:fig:console]</a>{reference-type=”autoref”
reference=”ch1:fig:console”} we see the screen of a system booted in
text mode, using the simple character display that the BIOS uses. In
responding to the keystrokes typed by the user, we can identify not only
the basic actions being performed (“run the <code class="docutils literal notranslate"><span class="pre">ls</span> <span class="pre">-l</span></code> command with output
to the console”) but a large number of interacting actions and
components as well:</p>
<div class="highlight-compactitem notranslate"><div class="highlight"><pre><span></span>the keyboard control hardware (assuming an old-fashioned PS/2 keyboard)
interrupts the processor, causing it to run a portion of the keyboard
input driver.

The driver reads data from the keyboard and calls scheduling functions
to wake the shell process, which was sleeping waiting for input.

the shell process spawns a copy of itself, by invoking a system call
which copies some of the shell process state and shares other parts of
it between the *parent* and *child* processes using the virtual memory
system.

The new process invokes the `exec` system call, causing the operating
system to map the `/bin/ls` binary into the process address space.

As `ls` starts up, the dynamic loader loads additional shared libraries
into the process address space; these as well as the `ls` code itself is
loaded into memory on demand as the CPU accesses them.

`ls` invokes system calls to read the list of files in the current
directory.

The file system code receives requests to read files containing the
executable and libraries, as well as the directory listing request from
the `ls` program itself, and in turn requests data from the disk (via
the block device system) to fulfill these requests.

Since the example was actually running in a virtual machine, not a
physical machine[^1] the hardware interactions described above were
actually emulated by another software system (i.e. VirtualBox) which
translated them into requests to the underlying operating system, which
in turn interacted with the real keyboard and screen.
</pre></div>
</div>
<p>The remainder of this book, and the corresponding class, is concerned
with the detailed analysis of the interactions involved in performing
this simple operation. The major sections of this text concern:</p>
<div class="highlight-compactdesc notranslate"><div class="highlight"><pre><span></span>**OS organization:** Memory organization and OS interface to decouple
applications from hardware and OS details, context switching, and system
calls. This section describes and uses a simple computer, described more
fully in the appendices.

**Synchronization:** Beginning with practical problems arising from
multiple simultaneous actions, we describe methods such as semaphores
and monitors to control simultaneous actions, as well as methods to
reason about the operation and performance of parallel operations.

**Virtual memory:** At the hardware level, how is address translation
implemented via the MMU, TLB, and page table? In the OS, how are page
faults used to implement copy-on-write, demand loading, and paged
virtual memory?

**Block devices:** These are devices such as disks, RAID arrays, and
SSDs, used for storing files and similar information. Topics covered
include performance and interfaces, I/O operation at a hardware level,
and methods of structuring I/O systems for reliability (RAID),
manageability (logical volume management) and efficiency
(deduplication).

**File systems:** What is a file system and what are its operations? How
do we implement these, and how do we lay files out on disk?

**Security:** What are the goals of security mechanisms in an operating
system? How can we specify and implement policies to control access and
operations?
</pre></div>
</div>
<p>The objective of the class is to be able to identify the steps involved
in this and other computer operations. In learning this we will touch on
hardware, device drivers, scheduling, virtual memory, and networking. We
focus on <em>behavior</em>—i.e. the sequence of events which occurs in
response to an input, and results in an output. This behavior cuts
across layers and subsystems, as an event at the hardware level may
trigger actions within a device driver, then in the core of the
operating system, within a user process, etc. Rather than looking at the
operating system in a structured way we are going to follow these
sequences of behavior and see where they lead.</p>
<section id="peter">
<h2><span class="section-number">8.1. </span>Peter<a class="headerlink" href="#peter" title="Permalink to this headline">#</a></h2>
</section>
</section>
<section class="tex2jax_ignore mathjax_ignore" id="program-and-os-organization-chap-osbasics">
<h1><span class="section-number">9. </span>Program and OS Organization {#chap:osbasics}<a class="headerlink" href="#program-and-os-organization-chap-osbasics" title="Permalink to this headline">#</a></h1>
<p>This chapter begins by defining a very simple computer, with assembly
language instructions, a 16-bit address space, and memory-mapped
peripherals.<a class="footnote-reference brackets" href="#id22" id="id1">1</a> We will use this computer as an example as we talk
about the simplest operating systems.</p>
<p>We then examine simple methods of organizing and running a program on
this computer. We extend these methods to hide hardware dependencies,
insulate against changes in operating system details, and allow for
program loading and execution—at this point we have achieved a simple
single-user OS, similar in many ways to MSDOS 1.0.</p>
<p>After this we examine multi-processing and context switching, allowing
multiple programs to be running simultaneously. Finally we examine what
additional features are needed to protect the operating system from the
user, and users from each other. At this point we have achieved a
simplified version of a modern operating system; we compare it to Linux
and Windows.</p>
<p><img alt="Simple computer systemarchitecture" src="intro/figures/csx600-arch2" />{#fig:ch2:arch width=”85%”}</p>
<section id="a-simple-computer">
<h2><span class="section-number">9.1. </span>A Simple Computer<a class="headerlink" href="#a-simple-computer" title="Permalink to this headline">#</a></h2>
<p>We use a fictional 16-bit computer, shown in
Figure <a class="reference external" href="#fig:ch2:arch">1.1</a>{reference-type=”ref”
reference=”fig:ch2:arch”}. It has 8 general-purpose registers, R0-R7,
holding 16 bits each, as well as a stack pointer (SP) and program
counter (PC), and 64 KB (<span class="math notranslate nohighlight">\(2^{16}\)</span>) of memory which may be accessed as
8-bit bytes or 16-bit words.</p>
<p>The examples below use the following instructions:</p>
<div class="highlight-enumerate* notranslate"><div class="highlight"><pre><span></span>LOAD.B, LOAD.W - load a byte or a word from the indicated address, which
may be an absolute address (i.e. a number) or contained in a register.

LOAD.I - load a constant value into a register. (called an &quot;immediate&quot;
value for unknown reasons)

STORE.B, STORE.W - store a byte or word from a register into memory.

MOV - copy the contents of one register to another.

ADD, SUB - add or subtract one register (or a constant value) to or from
another register. Sets the Z flag if the result is zero.

CMP - compare a register to another register or a constant value.
Subtracts the second value from the register, sets the Z flag
appropriately, and then throws away the result.

JMP - jump to the indicated address.

JMP_Z, JMP_NZ - jump if the Z flag is set (Z) or not set (NZ)

PUSH - push the 16-bit value in the indicated register onto the stack

POP - pop the 16-bit value top of the stack and place in the indicated
register.

CALL - call a subroutine by pushing the *return address* (i.e. the
address of the next instruction) onto the stack and jumping to the
indicated address.

RET - return from subroutine by popping the return address from the top
of the stack and jumping to it.
</pre></div>
</div>
<p>In addition there are several input/output devices which are
<em>memory-mapped</em>—particular memory addresses correspond to registers in
these devices, rather than normal memory, and reads or writes to these
addresses are used to operate the device. These devices include:</p>
<p><img alt="image" src="../_images/csx600-fbuf.png" />{width=”\textwidth”}\</p>
<p><br />
<img alt="image" src="../_images/csx600-kbd.png" />{width=”\textwidth”}\</p>
<p>\</p>
<div class="highlight-enumerate* notranslate"><div class="highlight"><pre><span></span>*frame buffer*: A region of 1920 bytes, corresponding to 24 lines of 80
characters displayed on a video display. Writing a byte to one of these
locations causes the indicated character to be displayed at the
corresponding location on the screen, as shown in
Figure [\[fig:osbasic:fbuf\]](#fig:osbasic:fbuf){reference-type=&quot;ref&quot;
reference=&quot;fig:osbasic:fbuf&quot;}.

*keyboard controller*: Two registers, one indicating whether a key has
been pressed, and the other the character corresponding to that key, as
shown in
Figure [\[fig:osbasic:kbd\]](#fig:osbasic:kbd){reference-type=&quot;ref&quot;
reference=&quot;fig:osbasic:kbd&quot;}.
</pre></div>
</div>
<p>This description is enough for our first examples; a full specification
is found in
Appendix <a class="reference external" href="#chap:cpux600">[chap:cpux600]</a>{reference-type=”ref”
reference=”chap:cpux600”}.</p>
<section id="review-questions">
<h3><span class="section-number">9.1.1. </span>Review Questions<a class="headerlink" href="#review-questions" title="Permalink to this headline">#</a></h3>
<div class="highlight-enumerate notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
</section>
</section>
<section id="program-organization">
<h2><span class="section-number">9.2. </span>Program Organization<a class="headerlink" href="#program-organization" title="Permalink to this headline">#</a></h2>
<p>Our first program is seen in
<a class="reference external" href="#ch2:lst:p1">[ch2:lst:p1]</a>{reference-type=”autoref”
reference=”ch2:lst:p1”}. It performs a very simple task, copying bytes
from a compiled-in string to the frame buffer to display (of course)
“Hello World” and then finishing in a loop which does nothing. (Although
the reader is not expected to write programs in assembly language, we
assume that given the computer definition you should be able to decipher
simple examples such as this.)</p>
<p>In <a class="reference external" href="#ch2:lst:p2">[ch2:lst:p2]</a>{reference-type=”autoref”
reference=”ch2:lst:p2”} we see another simple program, which performs
input as well as output. In the three lines starting at the label <code class="docutils literal notranslate"><span class="pre">loop</span></code>
it polls the keyboard status register, waiting for a key to be pressed.
It then reads the keystroke value into R4 and stores it into the frame
buffer. (Well, at least for the first 1920 keystrokes. It will advance
through the frame buffer line by line, ignoring carriage returns, and
eventually “fall off” the end and start scribbling over the rest of the
I/O space. It is a very simple program.)</p>
<p>These two programs illustrate the simplest sort of software
organization, consisting only of the program itself, which handles every
detail including the hardware interface—not a difficult task for such
a simple case. All there is here is a program and some hardware, with
nothing that we can identify as an operating system; this approach might
be appropriate for the smallest microcontrollers. (i.e. with a few
hundred bytes of program memory and even less data memory)</p>
</section>
<section id="a-simple-operating-system-interface">
<h2><span class="section-number">9.3. </span>A Simple Operating System Interface<a class="headerlink" href="#a-simple-operating-system-interface" title="Permalink to this headline">#</a></h2>
<div class="highlight-defn notranslate"><div class="highlight"><pre><span></span>*Operating system* - software that isn&#39;t the program itself, especially
that required by a user or program to interact with (i.e. *operate*) the
computer.
</pre></div>
</div>
<p>For even slightly complex programs we are going to want to factor out
the hardware interface functionality. This would e.g. allow us to use a
single function for output to the frame buffer, which could be called
from different places in the program. Our next program, in
<a class="reference external" href="#ch2:lst:p3">[ch2:lst:p3]</a>{reference-type=”autoref”
reference=”ch2:lst:p3”}, copies keystrokes from the keyboard to the
frame buffer just like our previous one. However, in this case we have
separated out the keyboard and display interface functions. With this we
start to see the beginnings of an operating system.</p>
<div class="highlight-{basicstyle=&quot;\ttfamily\footnotesize&quot; notranslate"><div class="highlight"><pre><span></span>loop:     CALL getkey       ;; return value in R0
              PUSH R0           ;; push argument
              CALL putchar
              POP R0            ;; to balance stack
              JMP loop

    getkey:   LOAD.B R4 $\leftarrow$ *(0xF800)  ;; key ready reg.
              CMP    R4, 0
              JMP_Z  getkey
              LOAD.B R0 $\leftarrow$ *(0xF801)  ;; key code reg.
              RET

    putchar:  LOAD.B R0 $\leftarrow$ *(SP+2)    ;; fetch arg into R0
              LOAD.W R1 $\leftarrow$ *(bufptr)
              STOR.B R0 $\rightarrow$ *(R1)      ;; *bufptr = R0
              ADD    R1+1 $\rightarrow$ R1
              STOR.W R1 $\rightarrow$ bufptr     ;; bufptr++
              RET

    bufptr:   word 0xF000       ;; frame buffer pointer
</pre></div>
</div>
<p>One goal of an operating system is to provide an abstract interface to
the hardware, serving several purposes. First, it allows a program
developed for one computer to be used on another one without extensive
modification, even if the hardware is not exactly the same. In addition,
by separating program-specific and hardware-specific code, it makes it
easier for each to be developed by someone who is expert in the
corresponding area.<a class="footnote-reference brackets" href="#id23" id="id2">2</a></p>
<p><a class="reference external" href="#ch2:lst:p3">[ch2:lst:p3]</a>{reference-type=”autoref”
reference=”ch2:lst:p3”} might be termed a <em>library operating
system</em>—it consists of a series of functions which are linked with the
application, creating a single program which is loaded onto the
hardware, frequently by being programmed into read-only-memory and thus
being present when the computer is first turned on.</p>
<p>Although this approach is useful for single-purpose devices, it has a
key shortcoming for general-purpose computers, in that changing the
program requires changing the entire contents of memory, requiring a
mechanism outside of the OS and program we have described so far. In
some cases, in fact, the only way to replace the program is to buy a new
device—this may in fact be reasonable for sufficiently “dumb” devices
(e.g. a microwave oven) but is clearly not going to be a popular way to
get a new program onto a computer.</p>
</section>
<section id="program-loading">
<h2><span class="section-number">9.4. </span>Program Loading<a class="headerlink" href="#program-loading" title="Permalink to this headline">#</a></h2>
<p><img alt="image" src="../_images/csx600-disk.png" />{height=”4\baselineskip”}</p>
<p>In order to load programs we need a device to load them from—in this
case a disk drive, which (unlike memory) maintains its data while
powered off, and is typically much larger than memory, allowing it to
hold multiple programs. Data on a disk drive is organized in 512-byte
blocks, which are identified by block number, starting with 0. In
Figure <a class="reference external" href="#fig:osbasics:diskctl">[fig:osbasics:diskctl]</a>{reference-type=”ref”
reference=”fig:osbasics:diskctl”} we see an extremely simple disk
controller, which allows a single block to be read from or written to
the disk<a class="footnote-reference brackets" href="#id24" id="id3">3</a>. Operation is as follows:</p>
<p>To write 512 bytes to block B:</p>
<div class="highlight-compactenum notranslate"><div class="highlight"><pre><span></span>Write 256 16-byte words (e.g. copying from a buffer), one word at a
time, to the disk controller data register (0xF824)

Write block address (B) to block address register (0xF822)

Write command byte (2=WRITE) to cmd/status register (address 0xF820)

Poll cmd/status register; its value will change from 2 to 0 to indicate
transfer is complete.
</pre></div>
</div>
<p>To read from block B:</p>
<div class="highlight-compactenum notranslate"><div class="highlight"><pre><span></span>Write block address (B) to block address register (0xF822)

Write command byte (1=READ) to cmd/status register (0xF820)

Poll cmd/status register; value changes from 1 to 0 to indicate data is
ready to read

Read 256 16-bit words from data register (0xF824), typically into a
buffer in memory.
</pre></div>
</div>
<p><img alt="image" src="../_images/memory-map-2.png" />{height=”15\baselineskip”}</p>
<p>Now that we have a device to load programs from, the next step is to
reserve separate portions of the address space for the OS and program,
as shown in <a class="reference external" href="#ch2:fig:map2">[ch2:fig:map2]</a>{reference-type=”autoref”
reference=”ch2:fig:map2”}, so that we have a place in memory to load
those programs into. The program links against the OS as before, but
this time the OS is located in a separate memory region, so different
programs (each compiled and linked against this same instance of the OS)
may be loaded and run at different times.</p>
<p>In <a class="reference external" href="#ch2:lst:p4">[ch2:lst:p4]</a>{reference-type=”autoref”
reference=”ch2:lst:p4”} we see pseudo-code<a class="footnote-reference brackets" href="#id25" id="id4">4</a> for a simple and
user-hostile command-line interface for this OS. The user specifies a
disk address and length; the OS loads a program from the specified disk
location into a standard address in memory and transfers control to that
address. When the program is finished it returns control to the OS
command line loop, which is then able to load and run a different
program.</p>
<p>There are a number of limitations to this operating system:</p>
<div class="highlight-compactenum notranslate"><div class="highlight"><pre><span></span>It&#39;s not robust: if it doesn&#39;t find the program you specified, it
crashes.

If the program crashes, the entire system has to be reset (or power
cycled) before another program can be loaded.

The program may not run on another machine, or on the same machine after
an OS upgrade.
</pre></div>
</div>
<p>Problem 1 can be fixed fairly easily; for instance if we have a simple
file system, and specify the file by name, then if the file isn’t found
the OS can print an error message and ask for another command. Problem 2
may be annoying, but it didn’t prevent MS-DOS from being the most
widely-used operating system for many years<a class="footnote-reference brackets" href="#id26" id="id5">5</a>. Problem 3 is an issue,
though, although first we have to describe why it is the case.</p>
<p>In particular, this operating system requires a certain amount of
coordination between the OS and the program: (a) The OS must know at
what address the program expects to begin execution—e.g. the <code class="docutils literal notranslate"><span class="pre">main()</span></code>
function in a C program or its equivalent. This isn’t too much of an
issue, as the OS authors can just tell the application (and compiler)
writers what to do. (e.g. in our case execution begins at the very
beginning of the program in memory) And (b) the program, in turn, must
have the correct addresses for any of the OS functions (e.g. <code class="docutils literal notranslate"><span class="pre">getkey</span></code> in
<a class="reference external" href="#ch2:lst:p3">[ch2:lst:p3]</a>{reference-type=”ref”
reference=”ch2:lst:p3”}) which it invokes.</p>
<p>This is where the problem lies. The location of these entry points may
vary from machine to machine due to e.g. different memory sizes, and
will almost certainly change across versions of the OS as code is added
(or occasionally removed) from some of its functions.</p>
<p>To work around this we typically define a standard set of entry points
into the OS, or <em>system calls</em>, access these entry points via a table
which is placed in a fixed location in memory (e.g. at address 0), and
give each system call a specific place in this table.</p>
<p>One way of implementing this is for the program to access this table
directly; thus if <code class="docutils literal notranslate"><span class="pre">getkey</span></code> is entry 2, programs could invoke it via the
call <code class="docutils literal notranslate"><span class="pre">syscall_table[2](args)</span></code>. Alternately, many CPUs define a TRAP or
INT<a class="footnote-reference brackets" href="#id27" id="id6">6</a> instruction which may be used for this purpose. In this case,
the table will be located in a location known to the CPU (either fixed,
as in the original 8088 where the table began at address 0, or
identified by a control register) and TRAP N will cause the CPU to
perform a function call to the <span class="math notranslate nohighlight">\(N^{th}\)</span> entry of this table.</p>
<p>We now have an interface which allows the OS to provide services to a
program via a fixed interface, allowing for binary compatibility across
different hardware platforms and OS versions. If we use a TRAP
instruction for this interface, we have a system similar to MS-DOS,
where OS and application were each given separate parts of a single
address space, and access to generic as well as hardware-specific OS
functions was performed via the x86 INT instruction.</p>
<section id="id7">
<h3><span class="section-number">9.4.1. </span>Review Questions<a class="headerlink" href="#id7" title="Permalink to this headline">#</a></h3>
<div class="highlight-enumerate notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
</section>
<section id="comparison-to-ms-dos-1-0">
<h3><span class="section-number">9.4.2. </span>Comparison to MS-DOS 1.0<a class="headerlink" href="#comparison-to-ms-dos-1-0" title="Permalink to this headline">#</a></h3>
<div class="highlight-wrapfigure notranslate"><div class="highlight"><pre><span></span>r0in
\[12\]\[0in\]![image](../images/pb-figures/intro/osbasics-msdos.png){height=&quot;15\\baselineskip&quot;}
</pre></div>
</div>
<p>This simple OS is very similar to the first version of MS-DOS. In MS-DOS
1.0, as seen in
Figure <a class="reference external" href="#fig:osbasic:msdos">[fig:osbasic:msdos]</a>{reference-type=”ref”
reference=”fig:osbasic:msdos”}, the operating system is split into 4
parts: a hardware-specific I/O system (BIOS), MS-DOS itself, the
resident part of the command line interpreter, and additional
“transient” parts of the command interpreter which could be over-written
by larger programs (especially on machines with 16KB RAM) and re-loaded
from floppy disk after the program exited.</p>
<p>Similarities with the simple OS include:</p>
<div class="highlight-compactenum notranslate"><div class="highlight"><pre><span></span>separate OS and program memory regions

a system call table accessed via INT instruction

a command line which is part of the OS

a keyboard controller, frame buffer, and disk controller which are much
like the CPU-5600 versions
</pre></div>
</div>
</section>
</section>
<section id="device-virtualization">
<h2><span class="section-number">9.5. </span>Device Virtualization<a class="headerlink" href="#device-virtualization" title="Permalink to this headline">#</a></h2>
<p>The <code class="docutils literal notranslate"><span class="pre">GET_LINE</span></code> and <code class="docutils literal notranslate"><span class="pre">getkey</span></code> operations just discussed are simple
examples of a powerful operating system concept—<em>device
virtualization</em>. Rather than requiring the programmer to write code
specific to a particular hardware implementation of a keyboard
controller, the operating system provides simple “virtual devices” to
the program, while the hardware details are handled within the operating
system. In particular, if these virtual devices are sufficiently generic
(e.g. supporting only <code class="docutils literal notranslate"><span class="pre">read</span></code> and <code class="docutils literal notranslate"><span class="pre">write</span></code> operations) then the same
program can read from the physical keyboard, from a window system which
sends keyboard data to the currently active window, from a file, or from
a network connection like <code class="docutils literal notranslate"><span class="pre">ssh</span></code>.</p>
<p>Implementing a generic I/O system like this is fairly straightforward,
as the set of I/O operations (open, close, read, write, etc.) is
basically an interface, while each particular device (e.g. keyboard,
disk file, etc.) can be thought of as a class implementing that
interface. In practice this is done by providing the program with a
<em>handle</em> or <em>descriptor</em> which maps to the actual I/O object within the
OS, and then implementing system calls such as <code class="docutils literal notranslate"><span class="pre">read</span></code> and <code class="docutils literal notranslate"><span class="pre">write</span></code> by
mapping the handle to the object, and then invoking the appropriate
method.</p>
<p>In Linux a file descriptor is an integer, used to index into a table of
files opened by the current process; a simplified version of the read
system call is seen in the example in
Listing <a class="reference external" href="#fig:ch2:virtio">[fig:ch2:virtio]</a>{reference-type=”ref”
reference=”fig:ch2:virtio”}.<a class="footnote-reference brackets" href="#id28" id="id8">7</a> The listing is somewhat
simplified—the actual code performs a few levels of indirection, some
locking, and a bounds check while looking up the ‘struct file’
corresponding to ‘fd’, and also handles the offset within the file. The
actual code is not that complex, however, as the complicated parts are
all in the file system or device-specific <code class="docutils literal notranslate"><span class="pre">read</span></code> methods.</p>
</section>
<section id="address-space-and-program-loading">
<h2><span class="section-number">9.6. </span>Address Space and Program Loading<a class="headerlink" href="#address-space-and-program-loading" title="Permalink to this headline">#</a></h2>
<p>Typically program address space is divided into the following parts:
<em>code</em> or machine-language instructions (for some reason typically
called “text”), <em>initialized data</em>, consisting of read-only and
read-write initialized data, <em>initialized-zero data</em>, called “BSS” for
obscure historical reasons, <em>heap</em> or dynamically allocated memory, and
<em>stack</em>.</p>
<hr class="docutils" />
<p><img alt="Awkward process memory map, with fixed-sized stackallocation." src="../_images/trad-addr-space.png" />{#fig:bad:addr
width=”0.8\columnwidth”}</p>
<hr class="docutils" />
<hr class="docutils" />
<p><img alt="Awkward process memory map, with fixed-sized stackallocation." src="../_images/bad-addr-space.png" />{#fig:bad:addr
width=”0.8\columnwidth”}</p>
<hr class="docutils" />
<p>In <a class="reference external" href="#fig:trad:addr">[fig:trad:addr]</a>{reference-type=”autoref”
reference=”fig:trad:addr”} we see the address space organization which
has evolved for arranging these areas for CPUs on which the stack grows
“down”—i.e. more recently pushed data is stored in lower-numbered
addresses. (this is by far the most common arrangement) In this
arrangement the fixed-sized portions of the address space are at the
bottom, and the heap grows “up” from there, while the stack grows “down”
from the highest available address. Assuming that the memory available
is contiguous, this gives the program maximum flexibility—it can use
most of the memory for dynamically-allocated heap, or for the stack, as
it chooses. In contrast, an organization such as
<a class="reference external" href="#fig:bad:addr">[fig:bad:addr]</a>{reference-type=”autoref”
reference=”fig:bad:addr”} would require a fixed allocation of the two
regions to be made when the program is loaded by the OS, adding
complexity while reducing flexibility. (Note that since the heap is
software-managed it can grow in whatever direction we want; however on
most CPUs the direction of stack growth is fixed.)</p>
<p>An additional goal of an address layout is to be able to accomodate
different amounts of available memory. As an example, early
microcomputers like the first IBM PCs might have between 16 KB and 64 KB
of memory; we would like the same program to be able to run on machines
with more or less memory, with the additional memory on the larger
machine available for heap or stack. This was typically done by starting
memory at address 0, so that a 16 KB machine would have available memory
address 0x0000 through 0x3FFF, while a 32 K machine would be able to use
0x0000 through 0x7FFF. Code and fixed data would be located starting at
a pre-defined offset near address 0, with stack and heap located above
these sections, at addresses which might vary from machine to machine
and program to program. This would ensure that small programs would be
placed in low addresses, so that they would be guaranteed to run on
low-memory machines, while the variability of stack and heap addresses
was not a significant issue because the compiler does not need to
generate direct references to them.</p>
</section>
<section id="interrupts">
<h2><span class="section-number">9.7. </span>Interrupts<a class="headerlink" href="#interrupts" title="Permalink to this headline">#</a></h2>
<p>So far all the code that we have looked at has been <em>synchronous</em>,
proceeding as a series of function calls reachable from some original
point at which execution started. This is a good model for programs, but
not always for operating systems, which may need to react to arbitrary
asynchronous events. (Consider for instance trying to stop a program
with control-C, if this only took effect when the program stopped and
checked for it.)</p>
<p>To handle asynchronous I/O events, CPUs provide an <em>interrupt</em>
mechanism. In response to a signal from an I/O device the CPU executes
an <em>interrupt handler</em> function, returning to its current execution when
the handler is done. The CPU essentially performs a forced function
call, saving the address of the next instruction on the stack and
jumping to the interrupt handler; the difference is that instead of
doing this in response to a CALL instruction, it does it at some
arbitrary time (but <em>between</em> two instructions) when the interrupt
signal is asserted<a class="footnote-reference brackets" href="#id29" id="id9">8</a>.</p>
<div class="highlight-footnotesize notranslate"><div class="highlight"><pre><span></span>
::: {#fig:ch2:x86ints}
  Index          Description          DOS name
  ------- ------------------------- ------------
  0            divide by zero       
  1              single step        
  2             non-maskable        
  3              debug break        
  4        debug break on overflow  
  5               -unused-          
  6            invalid instr.       
  7               -unused-          
  8             system timer            IRQ0
  9            keyboard input           IRQ1
  10           line printer 2        IRQ2, LPT2
  11            serial port 2        IRQ3, COM2
  12            serial port 1        IRQ4, COM1
  13              hard disk             IRQ5
  14             floppy disk            IRQ6
  15           line printer 1        IRQ7, LPT1
  16-         software-defined      
  255            interrupts         

  : 8086/8088 interrupts as defined by the IBM PC hardware.
</pre></div>
</div>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span>
Most CPUs have several interrupt inputs; these correspond to an
*interrupt vector table* in memory, either at a fixed location or
identified by a special register, giving the addresses of the
corresponding interrupt handlers. As an example, in
[\[fig:ch2:x86ints\]](#fig:ch2:x86ints){reference-type=&quot;autoref&quot;
reference=&quot;fig:ch2:x86ints&quot;} we see the corresponding table for an 8088
CPU as found in the original IBM PC, which provides handler addresses
for external hardware interrupts as well as *exceptions* which halt
normal program execution, such as dividing by zero or attempting to
execute an illegal instruction.

The simplest interrupt-generating device is a *timer*, which does
nothing except generate an interrupt at a periodic interval. In
Listing [\[lst:ch2:timer\]](#lst:ch2:timer){reference-type=&quot;ref&quot;
reference=&quot;lst:ch2:timer&quot;} we see why it is called a timer---one of its
most common uses is to keep track of time.

``` {xleftmargin=&quot;1.0in&quot; framexleftmargin=&quot;1.0in&quot; basicstyle=&quot;\\ttfamily\\footnotesize&quot;}
extern int time_in_ticks; 
    timer_interrupt_handler() {
        time_in_ticks++;
    }
```

Another simple use for interrupts is for notification of keyboard input.
Besides being useful for a &quot;cancel&quot; command like control-C, this is also
very useful for *type-ahead*. On slower computers (e.g. the original IBM
PC executed less than half a million instructions per second) a fast
typist can hit multiple keys while a program is busy. A simple keyboard
interface only holds one keystroke, causing additional ones to be lost.
By using the keyboard interrupt, as shown in
[\[fig:ch2:kbdint\]](#fig:ch2:kbdint){reference-type=&quot;autoref&quot;
reference=&quot;fig:ch2:kbdint&quot;}, the operating system can read these
keystrokes and save them, making them available to the program the next
time it checks for input.

::: framed
A question for the reader - how would you change the one-key type-ahead
buffer in
Figure [\[fig:ch2:kbdint\]](#fig:ch2:kbdint){reference-type=&quot;ref&quot;
reference=&quot;fig:ch2:kbdint&quot;} to buffer a larger number of keystrokes?
</pre></div>
</div>
<section id="id10">
<h3><span class="section-number">9.7.1. </span>Review Questions<a class="headerlink" href="#id10" title="Permalink to this headline">#</a></h3>
<div class="highlight-enumerate notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
</section>
</section>
<section id="context-switching">
<h2><span class="section-number">9.8. </span>Context Switching<a class="headerlink" href="#context-switching" title="Permalink to this headline">#</a></h2>
<p>Interrupt-driven type-ahead, as described above, represents a simple
form of multi-processing, or handling multiple parallel operations on
the same CPU. Full multi-processing, however, as found on modern
operating systems, involves parallel execution of full programs, rather
than merely interleaving a single program with specific bits of
operating system functionality.</p>
<p>Our simple OS cannot do this, nor can MS-DOS (which it closely
resembles), but it is a straightforward extension to do so even on
limited hardware. To do this on a single CPU machine we need a mechanism
for saving the state of a <em>process</em>—a running program—and restoring
it after another process has taken its turn.</p>
<hr class="docutils" />
<div class="highlight-{frame=&quot;none&quot; notranslate"><div class="highlight"><pre><span></span>f() {
   g(4, 5);
}
g(int n, m) {
   int a = 10;
   ...
}
</pre></div>
</div>
<hr class="docutils" />
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>SP $\rightarrow$
</pre></div>
</div>
<hr class="docutils" />
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>  5 (m)
</pre></div>
</div>
<hr class="docutils" />
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>  4 (n)
</pre></div>
</div>
<p>return addr
10 (a)</p>
<hr class="docutils" />
<p>To do this we take advantage of the way in which program state is stored
on the stack. This may be seen in
<a class="reference external" href="#ch2:lst:stack">[ch2:lst:stack]</a>{reference-type=”autoref”
reference=”ch2:lst:stack”}, where we see the stack frame generated by a
call to function <code class="docutils literal notranslate"><span class="pre">g()</span></code> with arguments and local variables.</p>
<p>By holding arguments, return addresses, and local variables, the stack
essentially captures all the private state of a running computation. If
we were to save the stack of a running process, go off and do something
else—taking care to use a different stack—and then switch stacks
again to return to the first process, no one would be the wiser except
for any delay incurred.</p>
<hr class="docutils" />
<hr class="docutils" />
<p>\</p>
<div class="highlight-{frame=&quot;none&quot; notranslate"><div class="highlight"><pre><span></span>sleep(time_t t) {
  end = now() + t;
  while (now() &lt; end)
     do nothing;
}
</pre></div>
</div>
<div class="highlight-{frame=&quot;none&quot; notranslate"><div class="highlight"><pre><span></span>sleep(time_t t) {
  ... switch() $\rightarrow$

  ... return $\leftarrow$
}

    [process A]
</pre></div>
</div>
<div class="highlight-{frame=&quot;none&quot; notranslate"><div class="highlight"><pre><span></span>
   $\rightarrow$   do something else
  ... for t seconds
   $\leftarrow$   then return


    [process B]
</pre></div>
</div>
<hr class="docutils" />
<hr class="docutils" />
<p>In fact, in <a class="reference external" href="#ch2:fig:sleep">[ch2:fig:sleep]</a>{reference-type=”autoref”
reference=”ch2:fig:sleep”} we see two implementations of the <code class="docutils literal notranslate"><span class="pre">sleep()</span></code>
function; the first busy-waits until the specified time has passed,
while the second uses some mechanism to switch to another program for a
while, and then returns when the interval is up. The particular
mechanism used to switch from one process to another is simple but
subtle: we save the processor registers by pushing them to the stack,
and then save the value of the stack pointer into another location in
memory. (This is commonly a location in a <em>process control block</em>, an
object which represents the state of a process when another one is
executing, and can be put on wait lists and otherwise manipulated.) We
can then switch to another process by loading the stack pointer value
for that second process (e.g. from its location in its process control
block), restoring registers from the stack, and returning.</p>
<p>The flow of control involved in such a context switch is difficult to
get used to, because the context switch itself <em>looks</em> like a simple
function call, but <em>behaves</em> in a radically different way. In your
previous classes you will have learned to think about functions as
abstract operations, returning by definition to the same place where
they were invoked. In a context switch, however, control enters the
function from one location, and after a few simple instructions returns
to an entirely different location.</p>
<hr class="docutils" />
<div class="highlight-{frame=&quot;none&quot; notranslate"><div class="highlight"><pre><span></span>switch_1_2:
    PUSH R0   # save registers
    PUSH R1
    ...
    STOR SP -&gt; proc1_sp
    LOAD SP &lt;- proc2_sp
    ... 
    POP R1
    POP R0    # restore them
    RET
</pre></div>
</div>
<p><img alt="Different ways of looking at a context switch from Process 1 toProcess 2." src="../_images/threads.png" />{#ch2:fig:thrds width=”\textwidth”}</p>
<hr class="docutils" />
<p>We see different representations of this in Figures
<a class="reference external" href="#ch2:fig:thrds">1.4</a>{reference-type=”ref” reference=”ch2:fig:thrds”}
and <a class="reference external" href="#ch2:fig:switch">[ch2:fig:switch]</a>{reference-type=”ref”
reference=”ch2:fig:switch”}. The context switch code is shown first: it
saves registers to process 1’s stack and saves the value of the stack
pointer, then loads process 2’s stack pointer, pops saved registers, and
returns. Note that the second half of the function is referring to an
entirely different stack than the first half, so the registers and
return address popped from the stack are different from the ones saved
in the first half of the function.</p>
<hr class="docutils" />
<hr class="docutils" />
<p><img alt="Simplified C run-time library (crt0.o) - invoke , and then call to terminate process, guaranteeing no return from the true startfunction." src="../_images/switch.png" />{#fig:start:main width=”95%”}</p>
<div class="highlight-{frame=&quot;none&quot; notranslate"><div class="highlight"><pre><span></span>_start() {
   /* prepare argc, argv */
   int val = main(argc, argv);
   exit(val);
   /* Not reached */
}
</pre></div>
</div>
<hr class="docutils" />
<hr class="docutils" />
<div class="highlight-gsidebar notranslate"><div class="highlight"><pre><span></span>A context switch enters a process or thread by **returning** from a
function call, and leaves the process by **calling** into the `switch`
function.
</pre></div>
</div>
<p>In addition we see two different visualizations of the flow of control
during context switch. In each case control enters <code class="docutils literal notranslate"><span class="pre">switch</span></code> via a call
from one process (or <em>thread</em> of control) but exits by returning to a
different process.</p>
<p><img alt="image" src="../_images/trampoline.png" />{height=”8\baselineskip”}</p>
<p>This is a curious property of context switching: we can only switch <em>to</em>
a process if we have switched <em>from</em> it at some point in the past. This
results in a chicken-and-egg<a class="footnote-reference brackets" href="#id30" id="id11">9</a> sort of problem—how do we start a
process in the first place? This is done via manipulating the stack “by
hand” in the process creation code, making it look like a previous call
was made to <span class="xref myst">switch</span>{.uri}, with a return address pointing to
the beginning of the code to be executed, forming what is called a
<em>trampoline</em> which “bounces” back to the desired location.</p>
<p>In <a class="reference external" href="#ch2:fig:tramp">[ch2:fig:tramp]</a>{reference-type=”autoref”
reference=”ch2:fig:tramp”} we see a thread being started so that it
begins execution with the first instruction of function <code class="docutils literal notranslate"><span class="pre">main()</span></code>.
Imagine that just before the beginning of <code class="docutils literal notranslate"><span class="pre">main()</span></code> there had been a call
to <code class="docutils literal notranslate"><span class="pre">context_switch</span></code>; when that call returns execution will begin at
address <code class="docutils literal notranslate"><span class="pre">main</span></code>. To start a thread which will begin at <code class="docutils literal notranslate"><span class="pre">main</span></code>, then, we
just fake this call stack; when we switch to the thread the first time,
<code class="docutils literal notranslate"><span class="pre">context_switch</span></code> will then return to location <code class="docutils literal notranslate"><span class="pre">main</span></code>, where execution
will begin.</p>
<p>A function is entered via <code class="docutils literal notranslate"><span class="pre">CALL</span></code> and exited via <code class="docutils literal notranslate"><span class="pre">RET</span></code>; similarly since
we enter a process via <code class="docutils literal notranslate"><span class="pre">RET</span></code>, we exit it via <code class="docutils literal notranslate"><span class="pre">CALL</span></code>. In particular, we
define a function (typically called <code class="docutils literal notranslate"><span class="pre">exit()</span></code>) which makes sure that the
process will never be switched to again. (e.g. it is removed from any
lists of processes to be run, its resources are freed, etc.) Note that
some programming languages (e.g. C) allow process execution to be
terminated by returning from the main function; this is done by calling
<code class="docutils literal notranslate"><span class="pre">main</span></code> from the “real” start function, as shown in
<a class="reference external" href="#fig:start:main">[fig:start:main]</a>{reference-type=”autoref”
reference=”fig:start:main”}.</p>
<section id="id12">
<h3><span class="section-number">9.8.1. </span>Review Questions<a class="headerlink" href="#id12" title="Permalink to this headline">#</a></h3>
<div class="highlight-enumerate notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
</section>
</section>
<section id="advanced-context-switching">
<h2><span class="section-number">9.9. </span>Advanced Context Switching<a class="headerlink" href="#advanced-context-switching" title="Permalink to this headline">#</a></h2>
<p><img alt="image" src="../_images/csx600-serial.png" />{height=”7\baselineskip”}</p>
<p>So far we have considered the case where switching between processes is
initiated by an explicit call into the OS from the currently running
process. But an interrupt is essentially a function call from the
current process into a part of the operating system—the interrupt
handler—and we can in fact context switch to another process from
within the interrupt handler function.<a class="footnote-reference brackets" href="#id31" id="id13">10</a> A simple example is the case
of the timer interrupt, which can easily be used to implement <em>time
slicing</em> between multiple processes. If the timer device was set to
interrupt every e.g. 20 ms, and its interrupt handler did nothing except
context switch to the next in a circular list of processes, then these
processes would share the CPU in 20 ms slices.</p>
<section id="scheduling">
<h3><span class="section-number">9.9.1. </span>Scheduling<a class="headerlink" href="#scheduling" title="Permalink to this headline">#</a></h3>
<p>Context switching is the mechanism used by the operating system to
switch from one running process to another; <em>scheduling</em> refers to the
decision the operating system must make as to <em>which</em> process to switch
to next. Scheduling is not covered in much detail in this version of the
text.</p>
</section>
<section id="multi-user-computer-system">
<h3><span class="section-number">9.9.2. </span>Multi-User Computer System<a class="headerlink" href="#multi-user-computer-system" title="Permalink to this headline">#</a></h3>
<p>Old (c. 1975?) multi-user computer system with 4 serial terminals.
fig:ch2:multiuser
<img alt="image" src="../_images/multi-user-mem-map.png" />{width=”0.95\columnwidth”} Possible
memory address layout for 4 processes plus operating system.
fig:ch2:serialin</p>
<p>We now have all the software mechanisms needed to construct a multi-user
computer system.Instead of a keyboard and video display we will use
<em>serial ports</em> connected to external terminals; the system is shown in
<a class="reference external" href="#fig:ch2:multiuser">[fig:ch2:multiuser]</a>{reference-type=”autoref”
reference=”fig:ch2:multiuser”} and the details of the memory-mapped
interface to the serial ports are shown in
<a class="reference external" href="#fig:ch2:serial">[fig:ch2:serial]</a>{reference-type=”autoref”
reference=”fig:ch2:serial”}. When the user types a character on their
terminal it will be transmitted over the serial line and received by the
serial port, which will set the input status to 1 and put the received
character in the input register. (just like the keyboard
controller)<a class="footnote-reference brackets" href="#id32" id="id14">11</a></p>
<p>To output data to the user a character is written to the output
register, which is then transmitted over the serial line and displayed
to the user by the terminal. It takes some amount of time to transmit a
character; during this time the output status register is set to 1, and
a new character should not be written until it returns to zero. Again
similar to the keyboard controller we can also perform interrupt-driven
I/O; in this case one interrupt indicates when a character has been
received, while a second indicates that a character has finished being
transmitted and we may send the next character.</p>
<section id="id15">
<h4><span class="section-number">9.9.2.1. </span>Review Questions<a class="headerlink" href="#id15" title="Permalink to this headline">#</a></h4>
<div class="highlight-enumerate notranslate"><div class="highlight"><pre><span></span>
</pre></div>
</div>
</section>
</section>
<section id="i-o-driven-context-switching">
<h3><span class="section-number">9.9.3. </span>I/O-driven Context Switching<a class="headerlink" href="#i-o-driven-context-switching" title="Permalink to this headline">#</a></h3>
<p>Now we know <em>how</em> to switch between programs, but <em>when</em> should we do
it? We see one possible answer in
<a class="reference external" href="#fig:ch2:serialin2">[fig:ch2:serialin2]</a>{reference-type=”autoref”
reference=”fig:ch2:serialin2”}—switching on user input. Many simple
programs (e.g. the shell, editors, etc.) consist of a user input loop:
the program waits for input from the user, processes it, displays any
resulting output, and then waits for user input again. Most of the time
the program is idle, waiting for input; we take advantage of this by
modifying the OS input routine to switch to another process when there
is no input ready.</p>
<p>The code in
<a class="reference external" href="#fig:ch2:serialin2">[fig:ch2:serialin2]</a>{reference-type=”autoref”
reference=”fig:ch2:serialin2”} will not switch to another process until
the current process explicitly requests more input. For input which
requires very little processing (e.g. an editor updating the screen)
this is fine. However, if the program were to perform large amounts of
computation before its next input request, then the other users might
not be able to get a response for a long period of time. We can address
this problem using interrupts: (1) When data is received for a program
which is waiting for input, we switch to that program, allowing it to
respond immediately. (2) When the timer interrupt fires we switch from
the currently running process to another running process. (A “running”
process is one that is not waiting for input—i.e. one that was
previously suspended by a timer interrupt.)</p>
</section>
</section>
<section id="address-spaces-for-multiple-processes">
<h2><span class="section-number">9.10. </span>Address Spaces for Multiple Processes<a class="headerlink" href="#address-spaces-for-multiple-processes" title="Permalink to this headline">#</a></h2>
<p>In <a class="reference external" href="#fig:ch2:serialin">[fig:ch2:serialin]</a>{reference-type=”autoref”
reference=”fig:ch2:serialin”} we see a possible address space layout for
our 4-user system, with four programs—one per terminal—each
receiving about a quarter of the available memory. There is one
significant problem, though: How do we get programs to run in these
different memory regions?</p>
<p>As mentioned earlier in this chapter, the location at which a program is
placed in memory is important, because there are many locations in a
typical program where the address of a portion of the program is needed
as part of an instruction. (e.g. for a subroutine call: on many CPUs, a
function call <code class="docutils literal notranslate"><span class="pre">f()</span></code> would be compiled to the instruction <code class="docutils literal notranslate"><span class="pre">CALL</span> <span class="pre">f</span></code>, with
the address of <code class="docutils literal notranslate"><span class="pre">f</span></code> forming part of the instruction.) If a program has
been compiled to start at a specific location in memory<a class="footnote-reference brackets" href="#id33" id="id16">12</a> then it
typically will not work if loaded into a different location.</p>
<p>There are a number of different ways to handle this problem:</p>
<div class="highlight-itemize* notranslate"><div class="highlight"><pre><span></span>*fixed-address compilation:* each program to be run on the system could
be compiled multiple times, once for each possible starting point, and
then the appropriate one loaded when a user runs a program. This seems
like a bad idea, as it is inflexible and complex in many different ways.
(e.g. it fixes the locations of the partitions, regardless of the total
system memory size, or the size of a program, or how many programs we
might wish to run at once) The only place I&#39;ve seen this approach used
is in certain embedded systems, where you may have multiple separate
programs running at once but they are all compiled together as part of a
single firmware version.

``` {xleftmargin=&quot;0.25\\textwidth&quot;}
200   CALL 500
      ...
500   ...

      (a)
```

``` {xleftmargin=&quot;0.25\\textwidth&quot;}
200  CALL PC+300
     ...
500  ...

     (b)
```

*position-independent code:* here we ensure that programs are compiled
in a way that makes them insensitive to their starting address, by using
what is called *PC-relative addressing*. This is illustrated in
[\[fig:pc:relative\]](#fig:pc:relative){reference-type=&quot;autoref&quot;
reference=&quot;fig:pc:relative&quot;}: rather than using an absolute address
(e.g. 500 in the figure) for a function call, we use an alternate
instruction which indicates an offset from the current PC. Unfortunately
this is frequently inefficient; for instance 32-bit Intel architecture
CPUs are able to efficiently perform PC-relative CALL and JMP
instructions, but require multiple instructions to perform a PC-relative
data access. (this was fixed in the 64-bit extensions)

*load-time fixup:* Here we defer the final determination of addresses
until the program is actually loaded into memory. The program file, or
*executable*, will thus contain not only the code and data to be loaded
into memory, but a list of locations which must be modified according to
the address at which the program is placed in memory. Thus in
[\[fig:pc:relative\]](#fig:pc:relative){reference-type=&quot;autoref&quot;
reference=&quot;fig:pc:relative&quot;}, this list would indicate how the target of
the CALL instruction should be calculated.[^13]

*hardware support:* By far the most popular way of sharing system memory
between multiple running programs is by the use of hardware address
translation; such hardware support is required to run modern
general-purpose operating systems such as Linux, Mac OS X, or Windows.
The basic idea is illustrated in
[\[fig:virtmem\]](#fig:virtmem){reference-type=&quot;autoref&quot;
reference=&quot;fig:virtmem&quot;}: the CPU uses *virtual addresses* for
instruction fetches or data loads and stores, which are then translated
by an MMU (Memory Management Unit) to *physical addresses* (i.e. the
actual address of a byte within a specific memory chip) for each memory
operation.
</pre></div>
</div>
</section>
<section id="memory-protection-and-translation">
<h2><span class="section-number">9.11. </span>Memory Protection and Translation<a class="headerlink" href="#memory-protection-and-translation" title="Permalink to this headline">#</a></h2>
<hr class="docutils" />
<p><img alt="Virtual-to-physical address translation. All addresses in the CPU arevirtual, and are translated to physical addresses by the MMU (MemoryManagement Unit) before being used to access physicalmemory." src="../_images/vm-virtual-trans.png" />{#fig:virtmem width=”70%”}</p>
<hr class="docutils" />
<p>Hardware-supported address translation and memory protection (e.g. see
Figure <a class="reference external" href="#fig:virtmem">1.6</a>{reference-type=”ref”
reference=”fig:virtmem”}) is used on all well-known general-purpose
operating systems today (e.g. Linux, OSX, Windows, and various server
operating systems) as well as many others (e.g. the OSes used on most
cell phones)<a class="footnote-reference brackets" href="#id34" id="id17">14</a>. Address translation is used for the following
reasons:</p>
<ul class="simple">
<li><p>Flexible sharing of memory between processes. As seen above, sharing
a single physical address space between a set of processes that
changes over time is complicated without hardware support. Address
translation allows programs to be compiled against a standard
virtual address space layout, which is then mapped to available
memory when the program is loaded into memory.</p></li>
<li><p>Security. On a multi-user computer there are obvious reasons for
preventing one user from accessing another’s data; to accomplish
this it is necessary to prevent “normal” processes from directly
accessing memory used by another process or by the operating system.
(even if the system is only used by one user at at time, the
operating system must be protected if it is to be relied on to
prevent access by one user to another user’s files.)</p></li>
<li><p>Robustness. If a program is allowed to write to any address in the
system, then a bug in that program may cause the entire system to
crash, e.g. by corrupting the operating system.<a class="footnote-reference brackets" href="#id35" id="id18">15</a> If a process is
constrained to only modifying memory that it has been allocated,
then the same bug would cause only that process to crash, after
which it may be restarted.</p></li>
</ul>
<p>It is possible to ensure this degree of protection with software
mechanisms under certain very limited circumstances, by e.g. restricting
user processes to only use Java bytecodes rather than direct program
execution.<a class="footnote-reference brackets" href="#id36" id="id19">16</a> In the normal case however, where an application is
allowed to directly execute most CPU instructions at full speed,
hardware support is needed to prevent a process from making unauthorized
memory reads and writes. This mechanism needs to be reconfigured by the
operating system on every context switch, to apply the correct set of
permissions to the running process, yet programs themselves must be
prevented from modifying the configuration to bypass permission
checking.</p>
<p>How can we allow the OS to modify memory protection, while preventing
user programs from doing so and subverting memory protection? This is
done by introducing a <em>processor state</em>: when the processor is running
in <em>user</em> mode it is not allowed to modify memory mapping configuration,
while when running in <em>supervisor</em> (also called <em>kernel</em>) mode it may do
so. The code of a normal application executes in user mode, while the
operating system <em>kernel</em><a class="footnote-reference brackets" href="#id37" id="id20">17</a> runs in supervisor mode. We next need a
mechanism for safely entering supervisor mode when either (a) an
application invokes a system call, or (b) a hardware interrupt occurs,
and then switching back to user mode when returning.</p>
<hr class="docutils" />
<p><img alt="image" src="../_images/vm-base-bounds.png" />{width=”90%”}<br />
(a) (b)  \</p>
<hr class="docutils" />
<div class="highlight-gsidebar notranslate"><div class="highlight"><pre><span></span>A question for the reader - what might happen if unprivileged programs
were able to modify the exception table?
</pre></div>
</div>
<p>This is typically done via the interrupt or exception mechanism, which
(as described earlier in this chapter) causes a forced function call in
response to certain events,to an address specified in a <em>exception
vector</em> or <em>exception table</em>. If we use an exception for invoking system
calls, and the CPU always switches to supervisor mode when handling
exceptions, then all operating system code will run in supervisor mode,
and a special instruction may be used to return back to user mode when a
system operation is complete. As long as the exception table is
protected from user-space modification, this hardware mechanism provides
the a basis on which a secure operating system may be built.</p>
<p>The simplest such address translation mechanism is known as <em>base</em> and
<em>bounds</em> registers, as illustrated in
<a class="reference external" href="#fig:base:n:bounds">[fig:base:n:bounds]</a>{reference-type=”autoref”
reference=”fig:base:n:bounds”}a. A virtual address is first checked to
ensure that it lies between 0 and a limit specified in the <em>bounds</em>
register; if this check fails, an exception is raised and the operating
system can terminate the process. Otherwise an offset (from the <em>base</em>
register) is added to the virtual address, giving the resulting physical
address. In this way a standard virtual address space (addresses 0
through the process size) is mapped onto an arbitrary (but contiguous)
range of physical memory, as shown in
<a class="reference external" href="#fig:base:n:bounds">[fig:base:n:bounds]</a>{reference-type=”autoref”
reference=”fig:base:n:bounds”}b.</p>
<p>There are a few complications in getting this to work with supervisor
mode, as it needs to be able to access OS data structures which are (a)
inaccessible to user-space code, and (b) at the same location in memory
no matter which user-space base register value is currently being used.
Although several techniques have been used, the simplest one is to
ignore base and bounds registers in supervisor mode, so that the
operating system uses physical addresses, giving access to all of
memory, while user processes execute in separate translated address
spaces<a class="footnote-reference brackets" href="#id38" id="id21">18</a>.</p>
<p>The switch from user to supervisor memory space (e.g. switching from
translating via the base+bounds registers to using direct addressing) is
done automatically by the hardware on any trap or interrupt. The
operating system is then free to change the values in the (user) base
and bounds registers to reflect the address space of the process it is
switching to.</p>
</section>
<section id="putting-it-all-together">
<h2><span class="section-number">9.12. </span>Putting it all together<a class="headerlink" href="#putting-it-all-together" title="Permalink to this headline">#</a></h2>
<p>In the introduction we saw the example of a simple command (<code class="docutils literal notranslate"><span class="pre">ls</span></code>) being
executed in Linux. Many of the details of its operation were covered in
this chapter.</p>
<p><strong>Hardware</strong>: In our example, the keyboard controller was for an
old-fashioned PS/2 keyboard, and the text display used was the simplest
text mode supported by PC hardware, normally only used by some BIOSes.
These are almost identical to the corresponding I/O devices in our
hypothetical computer—they’re located at different addresses, and
support a few extra functions (e.g. flashing letters, key-up and
key-down events, and keyboard <em>output</em> to e.g. turn on the caps-lock
light), but otherwise are the same.</p>
<p><strong>Code</strong>: To explain the operating system code we’ll use the 64-bit
Linux kernel version 4.6.0, because that’s what I have handy. (you can
browse and search the source code at
<a class="reference external" href="http://elixir.free-electrons.com/linux/v4.6/source">http://elixir.free-electrons.com/linux/v4.6/source</a>) If I use the
kernel debugger to put a breakpoint on the actual TTY read function
(<span class="xref myst">n_tty_read</span>{.uri}) we get the following backtrace, which
we will refer to in explaining input operation:</p>
<div class="highlight-{basicstyle=&quot;\ttfamily\scriptsize&quot; notranslate"><div class="highlight"><pre><span></span>(gdb) backtrace
#0  n_tty_read (tty=0xffff88003a99fc00, file=0xffff880036b3e900,
    buf=0x7ffcff243a77 &quot;&quot;, nr=1) at drivers/tty/n_tty.c:2123
#1  0xffffffff814d2792 in tty_read (file=0xffff880036b3e900, buf=&lt;optimized
    out&gt;, count=1, ppos=&lt;optimized out&gt;) at drivers/tty/tty_io.c:1082
#2  0xffffffff8121a197 in __vfs_read (file=0xffff88003a99fc00, buf=&lt;optimized
    out&gt;, count=&lt;optimized out&gt;, pos=0xffff88003b60bf18) at fs/read_write.c:473
#3  0xffffffff8121b236 in vfs_read (file=0xffff880036b3e900, buf=0x7ffcff243a77
    &quot;&quot;, count=&lt;optimized out&gt;, pos=0xffff88003b60bf18) at fs/read_write.c:495
#4  0xffffffff8121c725 in SYSC_read (count=&lt;optimized out&gt;, buf=&lt;optimized out&gt;, 
    fd=&lt;optimized out&gt;) at fs/read_write.c:610
#5  SyS_read (fd=&lt;optimized out&gt;, buf=140724589050487, count=1) at
    fs/read_write.c:603
#6  0xffffffff81798a76 in entry_SYSCALL_64 () at arch/x86/entry/entry_64.S:207
#7  0x0000000000000001 in irq_stack_union ()
#8  0x0000000000000000 in ?? ()
</pre></div>
</div>
<p><strong>System calls</strong>: The Linux command line is a separate program, the
<em>shell</em>, running in its own process, which invokes the <code class="docutils literal notranslate"><span class="pre">read</span></code> system
call by executing the [INT 0x80](INT 0x80){.uri} instructure with the
system call number (<span class="xref myst">SYS_READ</span>{.uri} = 3) in the
<span class="xref myst">EAX</span>{.uri} register, the file descriptor (stdin = 0) in <code class="docutils literal notranslate"><span class="pre">EBX</span></code>, a
buffer pointer in <code class="docutils literal notranslate"><span class="pre">ECX</span></code>, and the buffer length in <code class="docutils literal notranslate"><span class="pre">EDX</span></code> - see
<code class="docutils literal notranslate"><span class="pre">’man</span> <span class="pre">2</span> <span class="pre">read’</span></code> for a full description of the system call semantics.
(note that this is how it works for 32-bit mode; it’s slightly different
and more complicated for 64-bit.)</p>
<p>The <span class="xref myst">entry_SYSCALL_64</span>{.uri} function is the trap
handler; it saves all sorts of registers, checks that it’s a legal
system call number, and then calls the appropriate entry in the system
call table. (since it needs to save registers and perform other
machine-level functions it is one of the few kernel functions written in
machine language)</p>
<div class="highlight-{basicstyle=&quot;\ttfamily\scriptsize&quot; notranslate"><div class="highlight"><pre><span></span>#6  0xffffffff81798a76 in entry_SYSCALL_64 () at arch/x86/entry/entry_64.S:207
207             call    *sys_call_table(, %rax, 8)
</pre></div>
</div>
<div class="highlight-gsidebarN notranslate"><div class="highlight"><pre><span></span>13 Note that the operating system kernel is almost entirely composed of
exception handlers, which run in response to deliberate traps from user
applications (system calls) or accidental ones (e.g. memory access
faults), as well as interrupts from I/O devices and timers. This means
that when a system is idle it is not actually executing code in the
operating system kernel itself; instead a special *idle process* with
lowest priority executes when no other work is available.
</pre></div>
</div>
<p><strong>I/O virtualization</strong>: Linux file descriptors are small integers which
index into a per-process array of pointers to internal kernel file
structures. File descriptor 0 is standard input, and 1 is standard
output. The pointer to the current process structure is called
(unsurprisingly) <span class="xref myst">current</span>{.uri}; we can look into its file
table and see that entries 0 and 1 point to the same file structure
(ending in 3e900) passed to <span class="xref myst">n_tty_read</span>{.uri} in the stack
trace above:</p>
<div class="highlight-{mathescape=&quot;false&quot; notranslate"><div class="highlight"><pre><span></span>(gdb) p current-&gt;files.fdtab.fd[0]@2
$9 = {0xffff880036b3e900, 0xffff880036b3e900}
</pre></div>
</div>
<p>The <span class="xref myst">SYSC_read</span>{.uri} function looks up this structure
(returning an error for bad file descriptor numbers);
<span class="xref myst">vfs_read</span>{.uri} does a few more checks, and then calls
<span class="xref myst">__vfs_read</span>{.uri} which forwards to the “read” method
from the file operations table in the file structure:</p>
<div class="highlight-{basicstyle=&quot;\ttfamily\scriptsize&quot; notranslate"><div class="highlight"><pre><span></span>#2  0xffffffff8121a197 in __vfs_read (file=0xffff88003a99fc00, buf=&lt;optimized
    out&gt;, count=&lt;optimized out&gt;, pos=0xffff88003b60bf18) at fs/read_write.c:473
473                     return file-&gt;f_op-&gt;read(file, buf, count, pos);
</pre></div>
</div>
<p>When the file was originally opened, this operations table was set to
point to the read and write operations for the TTY driver, which is
responsible for keyboard input and text-mode screen output:</p>
<div class="highlight-{mathescape=&quot;false&quot; notranslate"><div class="highlight"><pre><span></span>(gdb) p file-&gt;f_op
$13 = (const struct file_operations *) 0xffffffff81872fa0 &lt;tty_fops&gt;
(gdb) p *file-&gt;f_op
$14 = {owner = 0x0, llseek = 0xffffffff81219ff0 &lt;no_llseek&gt;, 
  read = 0xffffffff814d2700 &lt;tty_read&gt;, write = 0xffffffff814d27f0 &lt;tty_write&gt;, 
  ...
</pre></div>
</div>
<p><strong>Context switching</strong>: In <span class="xref myst">n_tty_read</span>{.uri} it adds the
current process to a wait queue, then checks to see if there is any
input (or error conditions or lots of other reasons why it might return
early) and if none, it goes to sleep:</p>
<div class="highlight-{basicstyle=&quot;\ttfamily\scriptsize&quot; notranslate"><div class="highlight"><pre><span></span>2166            add_wait_queue(&amp;tty-&gt;read_wait, &amp;wait);
  ...
2188                    if (!input_available_p(tty, 0)) {
  ...
2207                            timeout = wait_woken(&amp;wait, TASK_INTERRUPTIBLE,
2208                                                 timeout);
</pre></div>
</div>
<p>Here <span class="xref myst">wait_woken</span>{.uri} sets a few things and then calls
<span class="xref myst">schedule_timeout</span>{.uri}, which sets a timer and then
calls <span class="xref myst">schedule</span>{.uri}, the central context switch function,
which picks the next runnable process and switches to it.</p>
<p>The interrupt which wakes it up is much more convoluted, as the actual
interrupt handler schedules a “deferred work” callback which does the
real work. (why? For several reasons, one of which is that you can block
in a deferred work handler while interrupts have to return immediately.)
Here are selected lines from the interrupt backtrace:</p>
<div class="highlight-{basicstyle=&quot;\ttfamily\scriptsize&quot; notranslate"><div class="highlight"><pre><span></span>#0  tty_schedule_flip (port=&lt;optimized out&gt;) at drivers/tty/tty_buffer.c:406
#1  tty_flip_buffer_push (port=0xffff88003e088000) 
    at drivers/tty/tty_buffer.c:558
#2  0xffffffff814dc8ae in tty_schedule_flip () at drivers/tty/tty_buffer.c:559
#3  0xffffffff814e490e in put_queue (ch=&lt;optimized out&gt;, vc=&lt;optimized out&gt;)
    at drivers/tty/vt/keyboard.c:306
 ... 
#8  0xffffffff814e5c11 in kbd_keycode (hw_raw=&lt;optimized out&gt;, down=&lt;optimized
    out&gt;, keycode=&lt;optimized out&gt;) at drivers/tty/vt/keyboard.c:1457
#9  kbd_event (handle=&lt;optimized out&gt;, event_type=&lt;optimized out&gt;,
    event_code=&lt;optimized out&gt;, value=2) at drivers/tty/vt/keyboard.c:1475
 ...
#16 atkbd_interrupt (serio=0xffff88003684e800, data=&lt;optimized out&gt;,
    flags=&lt;optimized out&gt;) at drivers/input/keyboard/atkbd.c:512
#17 0xffffffff8162fdc6 in serio_interrupt (serio=0xffff88003684e800, 
    data=57 &#39;9&#39;, dfl=0) at drivers/input/serio/serio.c:1006
#18 0xffffffff81630e72 in i8042_interrupt (irq=&lt;optimized out&gt;,
    dev_id=&lt;optimized out&gt;) at drivers/input/serio/i8042.c:548
 ...
#23 handle_irq (desc=&lt;optimized out&gt;, regs=&lt;optimized out&gt;) 
    at arch/x86/kernel/irq_64.c:78
#24 0xffffffff8179b22b in do_IRQ (regs=0xffffffff81c03df8
    &lt;init_thread_union+15864&gt;) at arch/x86/kernel/irq.c:240
</pre></div>
</div>
<p>which schedules the deferred work:</p>
<div class="highlight-{mathescape=&quot;false&quot; notranslate"><div class="highlight"><pre><span></span>#1  tty_schedule_flip (port=&lt;optimized out&gt;) at drivers/tty/tty_buffer.c:406
400             struct tty_bufhead *buf = &amp;port-&gt;buf;
 ...
406             queue_work(system_unbound_wq, &amp;buf-&gt;work);
(gdb) p *buf-&gt;work
$41 = {data = {counter = 64}, entry = {next = 0xffff88003e088010, 
  prev = 0xffff88003e088010}, func = 0xffffffff814dcd00 &lt;flush_to_ldisc&gt;}
</pre></div>
</div>
<p>If we put a breakpoint on <span class="xref myst">flush_to_ldisc</span>{.uri} and
step through it, you eventually get to the following lines:</p>
<div class="highlight-{basicstyle=&quot;\ttfamily\scriptsize&quot; notranslate"><div class="highlight"><pre><span></span>1628            if (read_cnt(ldata)) {
  ...
1630                    wake_up_interruptible_poll(&amp;tty-&gt;read_wait, POLLIN);
</pre></div>
</div>
<p>which wake up the shell process that was sleeping on
<span class="xref myst">tty-&gt;read_wait</span>{.uri}, by removing it from the queue
associated with <span class="xref myst">read_wait</span>{.uri} and reinserting it into the
list of runnable processes.</p>
<p><strong>Process creation</strong>: The shell process executes the <code class="docutils literal notranslate"><span class="pre">ls</span></code> command by
invoking <code class="docutils literal notranslate"><span class="pre">fork</span></code>, to create a subprocess, and then invoking <code class="docutils literal notranslate"><span class="pre">wait</span></code> to
wait until the subprocess has finished. Within the subprocess the <code class="docutils literal notranslate"><span class="pre">exec</span></code>
system call is used to load and execute the <code class="docutils literal notranslate"><span class="pre">ls</span></code> program itself; when it
is done the <code class="docutils literal notranslate"><span class="pre">exit</span></code> system call frees the subprocess and causes the
<code class="docutils literal notranslate"><span class="pre">wait</span></code> in the parent process to return. (process creation will be
covered in more depth when we look at virtual memory)</p>
<p><strong>Output</strong>: The shell and the <code class="docutils literal notranslate"><span class="pre">ls</span></code> processes send output to the screen
by using the <code class="docutils literal notranslate"><span class="pre">write</span></code> system call; the text console driver is responsible
for determining where the next character should be placed on the screen,
handling end-of-line, and copying data to scroll displayed text upwards
when it reaches the end of the buffer. (this way both processes can
output to the same screen without over-writing each other)</p>
<p>In particular, <span class="xref myst">tty_write</span>{.uri} eventually calls
<span class="xref myst">do_con_write</span>{.uri} in <code class="docutils literal notranslate"><span class="pre">drivers/tty/vt/vt.c</span></code>, which has a
bunch of convoluted logic to handle line wrap, scrolling, cursor control
commands, etc., but for the simplest case just adds on 8 bits to set the
right background and foreground color, and writes into the screen buffer
via a pointer:</p>
<div class="highlight-{basicstyle=&quot;\ttfamily\scriptsize&quot; notranslate"><div class="highlight"><pre><span></span>#define scr_writew(val, addr) (*(addr) = (val))
...
2384                scr_writew((vc_attr &lt;&lt; 8) + tc, 
                               (u16 *) vc-&gt;vc_pos);
</pre></div>
</div>
<section id="answers-to-review-questions">
<h3><span class="section-number">9.12.1. </span>Answers to Review Questions<a class="headerlink" href="#answers-to-review-questions" title="Permalink to this headline">#</a></h3>
<div class="highlight-compactenum notranslate"><div class="highlight"><pre><span></span>in osbasic:1,osbasic:2,osbasic:3,osbasic:4,osbasic:5
</pre></div>
</div>
<hr class="footnotes docutils" />
<dl class="footnote brackets">
<dt class="label" id="id22"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>It makes screenshots far easier.</p>
</dd>
<dt class="label" id="id23"><span class="brackets"><a class="fn-backref" href="#id2">2</a></span></dt>
<dd><p>Multiple levels of such separation are seen in modern computers,
where BIOS and hardware drivers are written by different
organizations, each knowledgeable about their own hardware, and
hiding the details and complications of these devices behind an
abstract interface.</p>
</dd>
<dt class="label" id="id24"><span class="brackets"><a class="fn-backref" href="#id3">3</a></span></dt>
<dd><p>For more information on disk drives, see
Section <a class="reference external" href="#sec:hdds">[sec:hdds]</a>{reference-type=”ref”
reference=”sec:hdds”} in
Chapter <a class="reference external" href="#chap:blockdevs">[chap:blockdevs]</a>{reference-type=”ref”
reference=”chap:blockdevs”}.</p>
</dd>
<dt class="label" id="id25"><span class="brackets"><a class="fn-backref" href="#id4">4</a></span></dt>
<dd><p>A generic term for anything that isn’t real program code, but
which you are supposed to understand anyway.</p>
</dd>
<dt class="label" id="id26"><span class="brackets"><a class="fn-backref" href="#id5">5</a></span></dt>
<dd><p>In that case it typically wasn’t necessary to turn off the power -
the low-level keyboard driver would reset the machine when it saw
CTL-ALT-DEL pressed at the same time.</p>
</dd>
<dt class="label" id="id27"><span class="brackets"><a class="fn-backref" href="#id6">6</a></span></dt>
<dd><p>the x86 “interrupt” instruction.</p>
</dd>
<dt class="label" id="id28"><span class="brackets"><a class="fn-backref" href="#id8">7</a></span></dt>
<dd><p>Like many other operating systems, Linux is written in C, which
lacks direct support for abstract interfaces and data types; the
actual implementation relies on a system of structures of function
pointers which is similar to how the compiler implements virtual
methods in C++.</p>
</dd>
<dt class="label" id="id29"><span class="brackets"><a class="fn-backref" href="#id9">8</a></span></dt>
<dd><p>This makes programming interrupt handlers quite tricky. Normally
the compiler saves many register values before calling a function,
and restores them afterwards; however an interrupt can occur
anytime, and if it accidentally forgets to save a register and then
modifies it, it will appear to the main program as if the register
value changed spontaneously. This isn’t good.</p>
</dd>
<dt class="label" id="id30"><span class="brackets"><a class="fn-backref" href="#id11">9</a></span></dt>
<dd><p>An English idiom referring to the rhetorical question “Which came
first, the chicken or the egg?”</p>
</dd>
<dt class="label" id="id31"><span class="brackets"><a class="fn-backref" href="#id13">10</a></span></dt>
<dd><p>Depending on the CPU there may be a few differences in stack
layout between an interrupt and a function call, but these can be
patched up in software.</p>
</dd>
<dt class="label" id="id32"><span class="brackets"><a class="fn-backref" href="#id14">11</a></span></dt>
<dd><p>It may seem to a modern reader that such a terminal would be as
complex as a computer; however the earliest terminals
(“teletypewriters”) were almost entirely mechanical.</p>
</dd>
<dt class="label" id="id33"><span class="brackets"><a class="fn-backref" href="#id16">12</a></span></dt>
<dd><p>E.g. 32-bit Linux programs are typically compiled to start at
address 0x8048000.</p>
</dd>
<dt class="label" id="id34"><span class="brackets"><a class="fn-backref" href="#id17">14</a></span></dt>
<dd><p>Address translation costs both money and power to add to a CPU;
thus for instance the iPod Touch has a CPU with address translation,
while the iPod Nano doesn’t.</p>
</dd>
<dt class="label" id="id35"><span class="brackets"><a class="fn-backref" href="#id18">15</a></span></dt>
<dd><p>This happened frequently in MS-DOS, which had no memory
protection.</p>
</dd>
<dt class="label" id="id36"><span class="brackets"><a class="fn-backref" href="#id19">16</a></span></dt>
<dd><p>For instance, this approach is used by the Inferno operating
system from Bell Labs, as well as several Java-based research
operating systems.</p>
</dd>
<dt class="label" id="id37"><span class="brackets"><a class="fn-backref" href="#id20">17</a></span></dt>
<dd><p>The core of the operating system, which does not run as a
process—i.e. ignoring system services which run as normal
processes.</p>
</dd>
<dt class="label" id="id38"><span class="brackets"><a class="fn-backref" href="#id21">18</a></span></dt>
<dd><p>This also makes it easier for the OS to change base+bounds
registers when switching between processes, as it will have no
effect on supervisor-mode address translation. Changing the mapping
of the memory region being currently executed—something which most
operating systems have to do very early in the boot process—is a
very tricky thing.</p>
</dd>
</dl>
</section>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./intro"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="tools.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title"><span class="section-number">6. </span>Tools</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="../scheduling/scheduling.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">10. </span>Processor Scheduling</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By Angela Demke Brown, Orran Krieger & Larry Woodman<br/>
  
      &copy; Copyright 2022.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>