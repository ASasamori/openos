
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>10.4. Scheduling in the real world &#8212; Introduction to Operating Systems</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" href="../_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script async="async" kind="hypothesis" src="https://hypothes.is/embed.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.20.1/dist/embed-amd.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="11. Review Questions" href="review.html" />
    <link rel="prev" title="10.3. Scheduling with Priorities" href="sch-prio.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../_static/logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">Introduction to Operating Systems</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../intro/pref.html">
                    Preface
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Getting started
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../intro/intro.html">
   1. Introduction
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../intro/purpose.html">
   2. Purpose of operating systems
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../intro/structure.html">
   3. Operating System Structure &amp; Unix/Linux
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../intro/abstractions.html">
   4. Operating System Abstractions
  </a>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../intro/tools.html">
   5. What you should know
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-1" name="toctree-checkbox-1" type="checkbox"/>
  <label for="toctree-checkbox-1">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../intro/tools-c.html">
     5.1. The C Programming Language
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../intro/tools-shell.html">
     5.2. Shell
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../intro/tools-editors.html">
     5.3. Editors
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../intro/tools-make.html">
     5.4. Make
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../intro/tools-testing.html">
     5.5. Testing
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../intro/tools-git.html">
     5.6. Git Basics
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../intro/tools-gdb.html">
     5.7. GDB
    </a>
   </li>
  </ul>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Virtual Processor
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="intro.html">
   6. Introduction
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="process.html">
   7. The Process: A virtual Computer
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="virtual.html">
   8. Virtualizing the CPU
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="threads.html">
   9. The Thread: A Virtual CPU
  </a>
 </li>
 <li class="toctree-l1 current active has-children">
  <a class="reference internal" href="scheduling.html">
   10. Scheduling
  </a>
  <input checked="" class="toctree-checkbox" id="toctree-checkbox-2" name="toctree-checkbox-2" type="checkbox"/>
  <label for="toctree-checkbox-2">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul class="current">
   <li class="toctree-l2">
    <a class="reference internal" href="sch-goals.html">
     10.1. Scheduling Goals
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="sch-simple.html">
     10.2. Simple Examples of Scheduling Policies
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="sch-prio.html">
     10.3. Scheduling with Priorities
    </a>
   </li>
   <li class="toctree-l2 current active">
    <a class="current reference internal" href="#">
     10.4. Scheduling in the real world
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="review.html">
   11. Review Questions
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Virtual Memory
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../mm/intro.html">
   12. Introduction
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../mm/phys-and-seg.html">
   13. Memory management before paged virtual memory
  </a>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../mm/pagvm.html">
   14. Paged Virtual memory
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-3" name="toctree-checkbox-3" type="checkbox"/>
  <label for="toctree-checkbox-3">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../mm/vmabs.html">
     14.1. Abstracting a useful interface for memory management.
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../mm/virt-paging.html">
     14.2. Paging
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../mm/page-tables.html">
     14.3. Page Tables
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../mm/reclamation.html">
     14.4. Memory reclaiming algorithms.
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../mm/page-size.html">
     14.5. Page Sizes
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../mm/pagefaults.html">
     14.6. Memory Management Page Faults
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../mm/buffer-cache.html">
   15. Buffer Cache
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../mm/realworld.html">
   16. Memory management in the real world
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../mm/concl.html">
   17. Conclusion
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../mm/review.html">
   18. Review
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  File Systems
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../fs/intro.html">
   19. Introduction
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../fs/interface.html">
   20. File System Abstraction
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../fs/diskhw.html">
   21. A bit about Disks
  </a>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../fs/impl.html">
   22. Implementation
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-4" name="toctree-checkbox-4" type="checkbox"/>
  <label for="toctree-checkbox-4">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../fs/disklayout.html">
     22.1. File System Layout
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../fs/dl_track_used.html">
     22.2. Disk Layout:Tracking Used Space
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../fs/dl_track_free.html">
     22.3. Disk Layout:Tracking Free Space
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../fs/dl_name.html">
     22.4. Disk Layout:Implementing Name Space
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../fs/dl_failures.html">
     22.5. Disk Layout:Dealing with Failures
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../fs/dl_ex_exx.html">
     22.6. Disk Layout:Examples of Real World File Systems
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../fs/kernelimp.html">
     22.7. Kernel implementation
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../fs/review.html">
   23. Review
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Concurrency
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../sync/sync.html">
   24. Introduction
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../sync/sharing.html">
   25. Cooperating Processes and Inter-process Communication
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../sync/criticalsection.html">
   26. The Critical Section Problem
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../sync/locks.html">
   27. Implementing Locks
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../sync/ordering.html">
   28. Ordering Thread Events
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../sync/concurrency_bugs.html">
   29. Common Concurrency Bugs
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../sync/readmostly.html">
   30. Read-Dominated Workloads
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../sync/hardware_challenges.html">
   31. Challenges of Modern Hardware
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../sync/linux_locking.html">
   32. Locking in the Linux Kernel
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../sync/review.html">
   33. Review
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Other Topics
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../devices/devices.html">
   34. Input and Output
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../devices/disk2.html">
   35. More on Disks
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../virt/virt.html">
   36. Virtualization
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../sec/sec.html">
   37. Security
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Appendices
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../misc/howto.html">
   38. How to read this book
  </a>
 </li>
 <li class="toctree-l1 has-children">
  <a class="reference internal" href="../contributing/intro.html">
   39. Contributing
  </a>
  <input class="toctree-checkbox" id="toctree-checkbox-5" name="toctree-checkbox-5" type="checkbox"/>
  <label for="toctree-checkbox-5">
   <i class="fas fa-chevron-down">
   </i>
  </label>
  <ul>
   <li class="toctree-l2">
    <a class="reference internal" href="../contributing/examples.html">
     39.1. Examples
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../contributing/credit.html">
     39.2. Contributors
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../contributing/Contributing.html">
     39.3. Contributing
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../contributing/resources.html">
     39.6. Resources to look at
    </a>
   </li>
   <li class="toctree-l2">
    <a class="reference internal" href="../contributing/fix.html">
     39.7. Out of date
    </a>
   </li>
  </ul>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../misc/bib.html">
   40. Bibliography
  </a>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<div class="menu-dropdown menu-dropdown-launch-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Launch interactive content">
      <i class="fas fa-rocket"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://jupyterhub-opf-jupyterhub.apps.smaug.na.operate-first.cloud/hub/user-redirect/git-pull?repo=https%3A//github.com/OpenOSOrg/openos&urlpath=lab/tree/openos/content/scheduling/sch-real.ipynb&branch=main"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Launch on JupyterHub"
>
  

<span class="headerbtn__icon-container">
  
    <img src="../_static/images/logo_jupyterhub.svg">
  </span>
<span class="headerbtn__text-container">JupyterHub</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>

<div class="menu-dropdown menu-dropdown-repository-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Source repositories">
      <i class="fab fa-github"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://github.com/OpenOSOrg/openos"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Source repository"
>
  

<span class="headerbtn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="headerbtn__text-container">repository</span>
</a>

      </li>
      
      <li>
        <a href="https://github.com/OpenOSOrg/openos/issues/new?title=Issue%20on%20page%20%2Fscheduling/sch-real.html&body=Your%20issue%20content%20here."
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Open an issue"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="headerbtn__text-container">open issue</span>
</a>

      </li>
      
      <li>
        <a href="https://github.com/OpenOSOrg/openos/edit/main/content/scheduling/sch-real.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Edit this page"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-pencil-alt"></i>
  </span>
<span class="headerbtn__text-container">suggest edit</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

<div class="menu-dropdown menu-dropdown-download-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Download this page">
      <i class="fas fa-download"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="../_sources/scheduling/sch-real.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Download source file"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="headerbtn__text-container">.ipynb</span>
</a>

      </li>
      
      <li>
        
<button onclick="printPdf(this)"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="left"
title="Print to PDF"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="headerbtn__text-container">.pdf</span>
</button>

      </li>
      
    </ul>
  </div>
</div>
<label for="__page-toc"
  class="headerbtn headerbtn-page-toc"
  
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-list"></i>
  </span>

</label>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
    <div class="tocsection onthispage pt-5 pb-3">
        <i class="fas fa-list"></i> Contents
    </div>
    <nav id="bd-toc-nav" aria-label="Page">
        <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#multi-cpu-scheduling">
   10.4.1. Multi-CPU scheduling
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#scheduling-in-linux">
   10.4.2. Scheduling in Linux
  </a>
 </li>
</ul>

    </nav>
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Scheduling in the real world</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#multi-cpu-scheduling">
   10.4.1. Multi-CPU scheduling
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#scheduling-in-linux">
   10.4.2. Scheduling in Linux
  </a>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <section class="tex2jax_ignore mathjax_ignore" id="scheduling-in-the-real-world">
<h1><span class="section-number">10.4. </span>Scheduling in the real world<a class="headerlink" href="#scheduling-in-the-real-world" title="Permalink to this headline">#</a></h1>
<p>We briefly review some of the real world scheduling issues and approaches from a Linux perspective.</p>
<section id="multi-cpu-scheduling">
<h2><span class="section-number">10.4.1. </span>Multi-CPU scheduling<a class="headerlink" href="#multi-cpu-scheduling" title="Permalink to this headline">#</a></h2>
<p>Today almost all systems have multiple CPUs.  Early multi-CPU systems looked something like <a class="reference internal" href="#smp-hw"><span class="std std-numref">Fig. 10.10</span></a> below.  If you compare with the simple computer picture we showed in the past (<a class="reference internal" href="../intro/purpose.html#simplecomputer-fig"><span class="std std-numref">Fig. 2.1</span></a>), there are just a modest number of CPUs accessing both the memory and I/O buses.</p>
<figure class="align-default" id="smp-hw">
<a class="reference internal image-reference" href="../_images/SMP.png"><img alt="../_images/SMP.png" src="../_images/SMP.png" style="width: 50%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 10.10 </span><span class="caption-text">Early  multiprocessors</span><a class="headerlink" href="#smp-hw" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>The easiest solution, and the one first adopted by most operating systems to support these computers, was to have a single runqueue in the kernel.  This is both simple, and fair, since whatever algorithm you apply for scheduling selects the best task to run irrespective of which CPU becomes available.</p>
<p>Unfortunately, today’s systems look more like <a class="reference internal" href="#numa-hw"><span class="std std-numref">Fig. 10.11</span></a>. They have memory controllers and I/O controllers in <em>sockets</em>, which is really just a processor chip.  The sockets have a large number of CPUs (or cores) each with their own caches, and a shared cache per socket.  Memory is directly attached to one of the sockets, and all accesses from other sockets have to go through it; leading to Non-Uniform Memory Access (NUMA).</p>
<figure class="align-default" id="numa-hw">
<a class="reference internal image-reference" href="../_images/NUMA.png"><img alt="../_images/NUMA.png" src="../_images/NUMA.png" style="width: 50%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 10.11 </span><span class="caption-text">Todays Multiprocessors</span><a class="headerlink" href="#numa-hw" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<p>In today’s systems a shared runqueue results in terrible performance.  First, if you have hundreds of cores, the run queue itself becomes a bottleneck since only one CPU at a time can add or remove tasks from the queue.  Second, with today’s large caches, you often want to run a task on the same CPU it ran on recently to reduce cache misses.  Third, modern systems are NUMA, or Non Unform Memory Access (NUMA), and you want to run a task on a CPU near the memory allocated to it.</p>
<p>Most systems have a seperate run queue per CPU, and use some algorithm to shift tasks from one CPU to another if the imbalance between the CPUs becomes too large.  The simplest algorithm, called take, has any CPU that becomes idle look at the load on the other CPUs to try to steal work.  You can see <a class="reference external" href="https://elixir.bootlin.com/linux/latest/source/kernel/sched/fair.c#L11206">here</a> the current code in Linux for the load_balancer that is called whenever a runqueue is empty and periodically to re-balance work across the runqueus.</p>
</section>
<section id="scheduling-in-linux">
<h2><span class="section-number">10.4.2. </span>Scheduling in Linux<a class="headerlink" href="#scheduling-in-linux" title="Permalink to this headline">#</a></h2>
<p>Given the enormous number of platforms Linux runs on, that covers everything from Batch scheduling HPC systems, to desktops, to embedded real time, the scheduling system has had to become incredibly adaptable.  You can find out a huge amount about it from the man page:</p>
<div class="cell tag_output_scroll tag_remove-input docutils container">
<div class="cell_output docutils container">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id": "2907ec0b0ce74d0da7306be053c9a40a", "version_major": 2, "version_minor": 0}
</script></div>
</div>
<p>Several snippets we would like to draw your attention to that relate strongly to the materials we have presented:</p>
<ul class="simple">
<li><p>Processes scheduled under one of the real-time policies (SCHED_FIFO, SCHED_RR) have a sched_priority value in the range  1 (low)  to  99  (high).   (As  the numbers imply, real-time threads always have higher priority than normal threads.) Conceptually, the scheduler maintains a list of runnable threads for each possible sched_priority value.  In order to  determine which thread runs next, the scheduler looks for the non empty list with the highest static priority and selects the thread at the head of this list.</p></li>
<li><p>All scheduling is preemptive: if a thread with a higher static priority becomes ready to run, the currently running thread will be preempted and returned to the wait list for its static priority level.  The scheduling policy determines  the  ordering only within the list of runnable threads with equal static priority.</p></li>
<li><p>Linux supports a number of policies that might sound familiar that can be specified on a per-task basis:</p>
<ul>
<li><p>SCHED_FIFO:  tasks will immediately preempt  any  currently  running  SCHED_OTHER,  SCHED_BATCH,  or  SCHED_IDLE  thread. SCHED_FIFO  is a simple scheduling algorithm without time slicing.</p></li>
<li><p>SCHED_RR: Round-robin scheduling - incorporates a quantum.</p></li>
<li><p>SCHED_DEADLINE: Sporadic task model deadline scheduling; period real time tasks, where user specifies the period, expected Runtime, and Deadline</p></li>
<li><p>SCHED_OTHER (or SCHED_NORMAL): Default Linux time-sharing scheduling the standard Linux time-sharing scheduler that is intended for all threads that do not require the special real-time mechanisms.  One can use <strong>nice</strong> to specify, depending on the schedular, the relative importance of different tasks.</p></li>
<li><p>SCHED_BATCH: This policy will cause the scheduler to always assume that the thread is CPU-intensive.</p></li>
<li><p>SCHED_IDLE: This policy is used for running jobs at extremely low priority.</p></li>
</ul>
</li>
</ul>
<p>Only privaledged tasks can set static prioritis; appropriate for single user systems where someone can specify the absolute priority of different work. The RLIMIT_RTTIME resource limit to set a ceiling on the CPU time that a real-time process may consume in order to gaurantee that real time tasks cannot cause starvation.</p>
<p>Prior to kernel version 2.6.23, the normal scheduler for Linux combined priority queues with a heuristic that altered a process’s priority based on the amount of a time slice it used. CPU-bound processes would consume their entire slice and would drop in priority. Conversely, I/O-bound processes would often block before consuming an entire time slice and so their priority would be increased. This was meant to allow for interactive processes to stay in the high priority queues and batch processing jobs (really anything that was CPU-bound) to drop. This scheduler had a number of heuristics that were used in decision making that were also exposed as tunable parameters, but the biggest feature it boasted was that it had O(1) run time. In other words, the time to select the next process was constant, regardless of how many runnable processes there were in the system.  This is basically a varient of the <a class="reference internal" href="sch-prio.html#cont-scheduling-scheduling-policies-mlf"><span class="std std-ref">MLF</span></a> we have discussed.</p>
<!--
tracks the amount of time each process has gotten, and the maximum time it would have expected to run on an ideal processor

I guess I don't get it, if it is just the vruntime, then even an interactive task that has been around for a long time will 

https://opensource.com/article/19/2/fair-scheduling-linux


Below is not accurate, there are multiple schedulers, 

talk about multi-CPU system, multiple scheduling...  say that the CFS is per CPU, 

SMP load-balancing has been reworked/sanitized: the runqueue-walking
assumptions are gone from the load-balancing code now, and iterators of the
scheduling modules are used.  The balancing code got quite a bit simpler as a
result.


https://www.kernel.org/doc/Documentation/scheduler/sched-design-CFS.txt

sched/fair.c implements the CFS scheduler described above.

sched/rt.c implements SCHED_FIFO and SCHED_RR semantics, in a simpler way than
the previous vanilla scheduler did.  It uses 100 runqueues (for all 100 RT
priority levels, instead of 140 in the previous scheduler) and it needs no
expired array.

-->
<p>The completely fair scheduler was a from-scratch redesign of the Linux scheduler; it did away with priority queues and with all<a class="footnote-reference brackets" href="#notall" id="id1">1</a> heuristics and tunables found in the O(1) scheduler. CFS introduced keeping a counter for the amount of runtime each task has received and this counter is used to decide on the next task to run. Instead of priority queues CFS places all tasks in a red-black tree sorted on their accumulated runtime with tasks on the left having less accumulated run time than tasks on the right. When the system needs a new task to run, the left most task is selected. This change allows CFS to completely avoid the starvation of CPU bound tasks that could occur with the previous scheduler.</p>
<hr class="footnotes docutils" />
<dl class="footnote brackets">
<dt class="label" id="notall"><span class="brackets"><a class="fn-backref" href="#id1">1</a></span></dt>
<dd><p>CFS still has a single tunable than can be exposed, but the kernel must be configured with <code class="docutils literal notranslate"><span class="pre">SCHED_DEBUG</span></code> selected.</p>
</dd>
</dl>
</section>
</section>


<script type="application/vnd.jupyter.widget-state+json">
{"state": {"2907ec0b0ce74d0da7306be053c9a40a": {"model_module": "@jupyter-widgets/output", "model_module_version": "1.0.0", "model_name": "OutputModel", "state": {"_dom_classes": [], "_model_module": "@jupyter-widgets/output", "_model_module_version": "1.0.0", "_model_name": "OutputModel", "_view_count": null, "_view_module": "@jupyter-widgets/output", "_view_module_version": "1.0.0", "_view_name": "OutputView", "layout": "IPY_MODEL_3d821f0bfe9541d8b4b959cc6a27e981", "msg_id": "", "outputs": [{"name": "stdout", "output_type": "stream", "text": "$ man sched\r\nSCHED(7)                   Linux Programmer's Manual                  SCHED(7)\r\n\r\nN\bNA\bAM\bME\bE\r\n       sched - overview of CPU scheduling\r\n\r\nD\bDE\bES\bSC\bCR\bRI\bIP\bPT\bTI\bIO\bON\bN\r\n       Since  Linux 2.6.23, the default scheduler is CFS, the \"Completely Fair\r\n       Scheduler\".  The CFS scheduler replaced the earlier \"O(1)\" scheduler.\r\n\r\n   A\bAP\bPI\bI s\bsu\bum\bmm\bma\bar\bry\by\r\n       Linux provides the following  system  calls  for  controlling  the  CPU\r\n       scheduling  behavior,  policy, and priority of processes (or, more pre\u2010\r\n       cisely, threads).\r\n\r\n       n\bni\bic\bce\be(2)\r\n              Set a new nice value for the calling thread, and return the  new\r\n              nice value.\r\n\r\n       g\bge\bet\btp\bpr\bri\bio\bor\bri\bit\bty\by(2)\r\n              Return  the  nice value of a thread, a process group, or the set\r\n              of threads owned by a specified user.\r\n\r\n       s\bse\bet\btp\bpr\bri\bio\bor\bri\bit\bty\by(2)\r\n              Set the nice value of a thread, a process group, or the  set  of\r\n              threads owned by a specified user.\r\n\r\n       s\bsc\bch\bhe\bed\bd_\b_s\bse\bet\bts\bsc\bch\bhe\bed\bdu\bul\ble\ber\br(2)\r\n              Set the scheduling policy and parameters of a specified thread.\r\n\r\n       s\bsc\bch\bhe\bed\bd_\b_g\bge\bet\bts\bsc\bch\bhe\bed\bdu\bul\ble\ber\br(2)\r\n              Return the scheduling policy of a specified thread.\r\n\r\n       s\bsc\bch\bhe\bed\bd_\b_s\bse\bet\btp\bpa\bar\bra\bam\bm(2)\r\n              Set the scheduling parameters of a specified thread.\r\n\r\n       s\bsc\bch\bhe\bed\bd_\b_g\bge\bet\btp\bpa\bar\bra\bam\bm(2)\r\n              Fetch the scheduling parameters of a specified thread.\r\n\r\n       s\bsc\bch\bhe\bed\bd_\b_g\bge\bet\bt_\b_p\bpr\bri\bio\bor\bri\bit\bty\by_\b_m\bma\bax\bx(2)\r\n              Return  the maximum priority available in a specified scheduling\r\n              policy.\r\n\r\n       s\bsc\bch\bhe\bed\bd_\b_g\bge\bet\bt_\b_p\bpr\bri\bio\bor\bri\bit\bty\by_\b_m\bmi\bin\bn(2)\r\n              Return the minimum priority available in a specified  scheduling\r\n              policy.\r\n\r\n       s\bsc\bch\bhe\bed\bd_\b_r\brr\br_\b_g\bge\bet\bt_\b_i\bin\bnt\bte\ber\brv\bva\bal\bl(2)\r\n              Fetch  the quantum used for threads that are scheduled under the\r\n              \"round-robin\" scheduling policy.\r\n\r\n       s\bsc\bch\bhe\bed\bd_\b_y\byi\bie\bel\bld\bd(2)\r\n              Cause the caller to relinquish  the  CPU,  so  that  some  other\r\n              thread be executed.\r\n\r\n       s\bsc\bch\bhe\bed\bd_\b_s\bse\bet\bta\baf\bff\bfi\bin\bni\bit\bty\by(2)\r\n              (Linux-specific) Set the CPU affinity of a specified thread.\r\n\r\n       s\bsc\bch\bhe\bed\bd_\b_g\bge\bet\bta\baf\bff\bfi\bin\bni\bit\bty\by(2)\r\n              (Linux-specific) Get the CPU affinity of a specified thread.\r\n\r\n       s\bsc\bch\bhe\bed\bd_\b_s\bse\bet\bta\bat\btt\btr\br(2)\r\n              Set  the scheduling policy and parameters of a specified thread.\r\n              This (Linux-specific) system call provides  a  superset  of  the\r\n              functionality of s\bsc\bch\bhe\bed\bd_\b_s\bse\bet\bts\bsc\bch\bhe\bed\bdu\bul\ble\ber\br(2) and s\bsc\bch\bhe\bed\bd_\b_s\bse\bet\btp\bpa\bar\bra\bam\bm(2).\r\n\r\n       s\bsc\bch\bhe\bed\bd_\b_g\bge\bet\bta\bat\btt\btr\br(2)\r\n              Fetch  the  scheduling  policy  and  parameters  of  a specified\r\n              thread.  This (Linux-specific) system call provides  a  superset\r\n              of  the  functionality  of  s\bsc\bch\bhe\bed\bd_\b_g\bge\bet\bts\bsc\bch\bhe\bed\bdu\bul\ble\ber\br(2) and s\bsc\bch\bhe\bed\bd_\b_g\bge\bet\bt\u2010\b\u2010\r\n              p\bpa\bar\bra\bam\bm(2).\r\n\r\n   S\bSc\bch\bhe\bed\bdu\bul\bli\bin\bng\bg p\bpo\bol\bli\bic\bci\bie\bes\bs\r\n       The scheduler is the  kernel  component  that  decides  which  runnable\r\n       thread will be executed by the CPU next.  Each thread has an associated\r\n       scheduling policy and a  _\bs_\bt_\ba_\bt_\bi_\bc  scheduling  priority,  _\bs_\bc_\bh_\be_\bd_\b__\bp_\br_\bi_\bo_\br_\bi_\bt_\by.\r\n       The  scheduler makes its decisions based on knowledge of the scheduling\r\n       policy and static priority of all threads on the system.\r\n\r\n       For threads scheduled under  one  of  the  normal  scheduling  policies\r\n       (S\bSC\bCH\bHE\bED\bD_\b_O\bOT\bTH\bHE\bER\bR,  S\bSC\bCH\bHE\bED\bD_\b_I\bID\bDL\bLE\bE,  S\bSC\bCH\bHE\bED\bD_\b_B\bBA\bAT\bTC\bCH\bH), _\bs_\bc_\bh_\be_\bd_\b__\bp_\br_\bi_\bo_\br_\bi_\bt_\by is not used in\r\n       scheduling decisions (it must be specified as 0).\r\n\r\n       Processes scheduled under one of the  real-time  policies  (S\bSC\bCH\bHE\bED\bD_\b_F\bFI\bIF\bFO\bO,\r\n       S\bSC\bCH\bHE\bED\bD_\b_R\bRR\bR)  have  a  _\bs_\bc_\bh_\be_\bd_\b__\bp_\br_\bi_\bo_\br_\bi_\bt_\by  value  in  the  range 1 (low) to 99\r\n       (high).  (As the numbers imply, real-time threads  always  have  higher\r\n       priority  than  normal threads.)  Note well: POSIX.1 requires an imple\u2010\r\n       mentation to support only a minimum 32 distinct priority levels for the\r\n       real-time  policies, and some systems supply just this minimum.  Porta\u2010\r\n       ble programs should use s\bsc\bch\bhe\bed\bd_\b_g\bge\bet\bt_\b_p\bpr\bri\bio\bor\bri\bit\bty\by_\b_m\bmi\bin\bn(2) and  s\bsc\bch\bhe\bed\bd_\b_g\bge\bet\bt_\b_p\bpr\bri\bio\bor\br\u2010\b\u2010\r\n       i\bit\bty\by_\b_m\bma\bax\bx(2)  to  find the range of priorities supported for a particular\r\n       policy.\r\n\r\n       Conceptually, the scheduler maintains a list of  runnable  threads  for\r\n       each possible _\bs_\bc_\bh_\be_\bd_\b__\bp_\br_\bi_\bo_\br_\bi_\bt_\by value.  In order to determine which thread\r\n       runs next, the scheduler looks for the nonempty list with  the  highest\r\n       static priority and selects the thread at the head of this list.\r\n\r\n       A  thread's scheduling policy determines where it will be inserted into\r\n       the list of threads with equal static priority and how it will move in\u2010\r\n       side this list.\r\n\r\n       All scheduling is preemptive: if a thread with a higher static priority\r\n       becomes ready to run, the currently running thread  will  be  preempted\r\n       and  returned  to  the  wait  list  for its static priority level.  The\r\n       scheduling policy determines the  ordering  only  within  the  list  of\r\n       runnable threads with equal static priority.\r\n\r\n   S\bSC\bCH\bHE\bED\bD_\b_F\bFI\bIF\bFO\bO:\b: F\bFi\bir\brs\bst\bt i\bin\bn-\b-f\bfi\bir\brs\bst\bt o\bou\but\bt s\bsc\bch\bhe\bed\bdu\bul\bli\bin\bng\bg\r\n       S\bSC\bCH\bHE\bED\bD_\b_F\bFI\bIF\bFO\bO can be used only with static priorities higher than 0, which\r\n       means that when a S\bSC\bCH\bHE\bED\bD_\b_F\bFI\bIF\bFO\bO thread becomes runnable,  it  will  always\r\n       immediately  preempt any currently running S\bSC\bCH\bHE\bED\bD_\b_O\bOT\bTH\bHE\bER\bR, S\bSC\bCH\bHE\bED\bD_\b_B\bBA\bAT\bTC\bCH\bH, or\r\n       S\bSC\bCH\bHE\bED\bD_\b_I\bID\bDL\bLE\bE thread.  S\bSC\bCH\bHE\bED\bD_\b_F\bFI\bIF\bFO\bO is a simple scheduling algorithm without\r\n       time  slicing.   For threads scheduled under the S\bSC\bCH\bHE\bED\bD_\b_F\bFI\bIF\bFO\bO policy, the\r\n       following rules apply:\r\n\r\n       1) A running S\bSC\bCH\bHE\bED\bD_\b_F\bFI\bIF\bFO\bO thread  that  has  been  preempted  by  another\r\n          thread  of higher priority will stay at the head of the list for its\r\n          priority and will resume execution as soon as all threads of  higher\r\n          priority are blocked again.\r\n\r\n       2) When  a  blocked  S\bSC\bCH\bHE\bED\bD_\b_F\bFI\bIF\bFO\bO thread becomes runnable, it will be in\u2010\r\n          serted at the end of the list for its priority.\r\n\r\n       3) If a call  to  s\bsc\bch\bhe\bed\bd_\b_s\bse\bet\bts\bsc\bch\bhe\bed\bdu\bul\ble\ber\br(2),  s\bsc\bch\bhe\bed\bd_\b_s\bse\bet\btp\bpa\bar\bra\bam\bm(2),  s\bsc\bch\bhe\bed\bd_\b_s\bse\be\u2010\b\u2010\r\n          t\bta\bat\btt\btr\br(2),   p\bpt\bth\bhr\bre\bea\bad\bd_\b_s\bse\bet\bts\bsc\bch\bhe\bed\bdp\bpa\bar\bra\bam\bm(3),   or   p\bpt\bth\bhr\bre\bea\bad\bd_\b_s\bse\bet\bts\bsc\bch\bhe\bed\bdp\bpr\bri\bio\bo(3)\r\n          changes the priority of the running or  runnable  S\bSC\bCH\bHE\bED\bD_\b_F\bFI\bIF\bFO\bO  thread\r\n          identified  by  _\bp_\bi_\bd  the effect on the thread's position in the list\r\n          depends on the direction of the change to threads priority:\r\n\r\n          \u2022  If the thread's priority is raised, it is placed at  the  end  of\r\n             the  list for its new priority.  As a consequence, it may preempt\r\n             a currently running thread with the same priority.\r\n\r\n          \u2022  If the thread's priority is unchanged, its position  in  the  run\r\n             list is unchanged.\r\n\r\n          \u2022  If the thread's priority is lowered, it is placed at the front of\r\n             the list for its new priority.\r\n\r\n          According to POSIX.1-2008, changes to a thread's priority  (or  pol\u2010\r\n          icy)  using  any mechanism other than p\bpt\bth\bhr\bre\bea\bad\bd_\b_s\bse\bet\bts\bsc\bch\bhe\bed\bdp\bpr\bri\bio\bo(3) should\r\n          result in the thread being placed at the end of  the  list  for  its\r\n          priority.\r\n\r\n       4) A thread calling s\bsc\bch\bhe\bed\bd_\b_y\byi\bie\bel\bld\bd(2) will be put at the end of the list.\r\n\r\n       No  other events will move a thread scheduled under the S\bSC\bCH\bHE\bED\bD_\b_F\bFI\bIF\bFO\bO pol\u2010\r\n       icy in the wait list of runnable threads with equal static priority.\r\n\r\n       A S\bSC\bCH\bHE\bED\bD_\b_F\bFI\bIF\bFO\bO thread runs until either it is blocked by an I/O  request,\r\n       it   is   preempted   by   a   higher  priority  thread,  or  it  calls\r\n       s\bsc\bch\bhe\bed\bd_\b_y\byi\bie\bel\bld\bd(2).\r\n\r\n   S\bSC\bCH\bHE\bED\bD_\b_R\bRR\bR:\b: R\bRo\bou\bun\bnd\bd-\b-r\bro\bob\bbi\bin\bn s\bsc\bch\bhe\bed\bdu\bul\bli\bin\bng\bg\r\n       S\bSC\bCH\bHE\bED\bD_\b_R\bRR\bR is a simple enhancement of S\bSC\bCH\bHE\bED\bD_\b_F\bFI\bIF\bFO\bO.   Everything  described\r\n       above  for S\bSC\bCH\bHE\bED\bD_\b_F\bFI\bIF\bFO\bO also applies to S\bSC\bCH\bHE\bED\bD_\b_R\bRR\bR, except that each thread\r\n       is allowed to run only for a  maximum  time  quantum.   If  a  S\bSC\bCH\bHE\bED\bD_\b_R\bRR\bR\r\n       thread  has  been running for a time period equal to or longer than the\r\n       time quantum, it will be put at the end of the list for  its  priority.\r\n       A  S\bSC\bCH\bHE\bED\bD_\b_R\bRR\bR  thread that has been preempted by a higher priority thread\r\n       and subsequently resumes execution as a running  thread  will  complete\r\n       the  unexpired  portion of its round-robin time quantum.  The length of\r\n       the time quantum can be retrieved using s\bsc\bch\bhe\bed\bd_\b_r\brr\br_\b_g\bge\bet\bt_\b_i\bin\bnt\bte\ber\brv\bva\bal\bl(2).\r\n\r\n   S\bSC\bCH\bHE\bED\bD_\b_D\bDE\bEA\bAD\bDL\bLI\bIN\bNE\bE:\b: S\bSp\bpo\bor\bra\bad\bdi\bic\bc t\bta\bas\bsk\bk m\bmo\bod\bde\bel\bl d\bde\bea\bad\bdl\bli\bin\bne\be s\bsc\bch\bhe\bed\bdu\bul\bli\bin\bng\bg\r\n       Since  version  3.14,  Linux  provides  a  deadline  scheduling  policy\r\n       (S\bSC\bCH\bHE\bED\bD_\b_D\bDE\bEA\bAD\bDL\bLI\bIN\bNE\bE).   This  policy  is  currently  implemented using GEDF\r\n       (Global Earliest Deadline First)  in  conjunction  with  CBS  (Constant\r\n       Bandwidth  Server).   To  set  and fetch this policy and associated at\u2010\r\n       tributes,  one  must  use  the  Linux-specific   s\bsc\bch\bhe\bed\bd_\b_s\bse\bet\bta\bat\btt\btr\br(2)   and\r\n       s\bsc\bch\bhe\bed\bd_\b_g\bge\bet\bta\bat\btt\btr\br(2) system calls.\r\n\r\n       A  sporadic  task is one that has a sequence of jobs, where each job is\r\n       activated at most once per period.  Each job also has a _\br_\be_\bl_\ba_\bt_\bi_\bv_\be  _\bd_\be_\ba_\bd_\b\u2010\r\n       _\bl_\bi_\bn_\be,  before which it should finish execution, and a _\bc_\bo_\bm_\bp_\bu_\bt_\ba_\bt_\bi_\bo_\bn _\bt_\bi_\bm_\be,\r\n       which is the CPU time necessary for executing the job.  The moment when\r\n       a  task wakes up because a new job has to be executed is called the _\ba_\br_\b\u2010\r\n       _\br_\bi_\bv_\ba_\bl _\bt_\bi_\bm_\be (also referred to as the request time or release time).  The\r\n       _\bs_\bt_\ba_\br_\bt _\bt_\bi_\bm_\be is the time at which a task starts its execution.  The _\ba_\bb_\bs_\bo_\b\u2010\r\n       _\bl_\bu_\bt_\be _\bd_\be_\ba_\bd_\bl_\bi_\bn_\be is thus obtained by adding the relative deadline  to  the\r\n       arrival time.\r\n\r\n       The following diagram clarifies these terms:\r\n\r\n           arrival/wakeup                    absolute deadline\r\n                |    start time                    |\r\n                |        |                         |\r\n                v        v                         v\r\n           -----x--------xooooooooooooooooo--------x--------x---\r\n                         |<- comp. time ->|\r\n                |<------- relative deadline ------>|\r\n                |<-------------- period ------------------->|\r\n\r\n       When  setting  a  S\bSC\bCH\bHE\bED\bD_\b_D\bDE\bEA\bAD\bDL\bLI\bIN\bNE\bE  policy  for  a thread using s\bsc\bch\bhe\bed\bd_\b_s\bse\be\u2010\b\u2010\r\n       t\bta\bat\btt\btr\br(2), one can specify three parameters: _\bR_\bu_\bn_\bt_\bi_\bm_\be, _\bD_\be_\ba_\bd_\bl_\bi_\bn_\be, and  _\bP_\be_\b\u2010\r\n       _\br_\bi_\bo_\bd.   These parameters do not necessarily correspond to the aforemen\u2010\r\n       tioned terms: usual practice is to set Runtime to something bigger than\r\n       the  average  computation  time  (or worst-case execution time for hard\r\n       real-time tasks), Deadline to the relative deadline, and Period to  the\r\n       period of the task.  Thus, for S\bSC\bCH\bHE\bED\bD_\b_D\bDE\bEA\bAD\bDL\bLI\bIN\bNE\bE scheduling, we have:\r\n\r\n           arrival/wakeup                    absolute deadline\r\n                |    start time                    |\r\n                |        |                         |\r\n                v        v                         v\r\n           -----x--------xooooooooooooooooo--------x--------x---\r\n                         |<-- Runtime ------->|\r\n                |<----------- Deadline ----------->|\r\n                |<-------------- Period ------------------->|\r\n\r\n       The  three  deadline-scheduling parameters correspond to the _\bs_\bc_\bh_\be_\bd_\b__\br_\bu_\bn_\b\u2010\r\n       _\bt_\bi_\bm_\be, _\bs_\bc_\bh_\be_\bd_\b__\bd_\be_\ba_\bd_\bl_\bi_\bn_\be, and _\bs_\bc_\bh_\be_\bd_\b__\bp_\be_\br_\bi_\bo_\bd fields of the _\bs_\bc_\bh_\be_\bd_\b__\ba_\bt_\bt_\br  struc\u2010\r\n       ture;  see  s\bsc\bch\bhe\bed\bd_\b_s\bse\bet\bta\bat\btt\btr\br(2).   These fields express values in nanosec\u2010\r\n       onds.  If _\bs_\bc_\bh_\be_\bd_\b__\bp_\be_\br_\bi_\bo_\bd is specified as 0, then it is made the  same  as\r\n       _\bs_\bc_\bh_\be_\bd_\b__\bd_\be_\ba_\bd_\bl_\bi_\bn_\be.\r\n\r\n       The kernel requires that:\r\n\r\n           sched_runtime <= sched_deadline <= sched_period\r\n\r\n       In  addition,  under  the  current implementation, all of the parameter\r\n       values must be at least 1024 (i.e., just over one microsecond, which is\r\n       the  resolution  of the implementation), and less than 2^63.  If any of\r\n       these checks fails, s\bsc\bch\bhe\bed\bd_\b_s\bse\bet\bta\bat\btt\btr\br(2) fails with the error E\bEI\bIN\bNV\bVA\bAL\bL.\r\n\r\n       The  CBS  guarantees  non-interference  between  tasks,  by  throttling\r\n       threads that attempt to over-run their specified Runtime.\r\n\r\n       To ensure deadline scheduling guarantees, the kernel must prevent situ\u2010\r\n       ations where the set of S\bSC\bCH\bHE\bED\bD_\b_D\bDE\bEA\bAD\bDL\bLI\bIN\bNE\bE threads is not feasible (schedu\u2010\r\n       lable)  within  the given constraints.  The kernel thus performs an ad\u2010\r\n       mittance test when setting or changing S\bSC\bCH\bHE\bED\bD_\b_D\bDE\bEA\bAD\bDL\bLI\bIN\bNE\bE  policy  and  at\u2010\r\n       tributes.   This admission test calculates whether the change is feasi\u2010\r\n       ble; if it is not, s\bsc\bch\bhe\bed\bd_\b_s\bse\bet\bta\bat\btt\btr\br(2) fails with the error E\bEB\bBU\bUS\bSY\bY.\r\n\r\n       For example, it is required (but not necessarily  sufficient)  for  the\r\n       total  utilization to be less than or equal to the total number of CPUs\r\n       available, where, since each thread can maximally run for  Runtime  per\r\n       Period, that thread's utilization is its Runtime divided by its Period.\r\n\r\n       In  order  to fulfill the guarantees that are made when a thread is ad\u2010\r\n       mitted to the S\bSC\bCH\bHE\bED\bD_\b_D\bDE\bEA\bAD\bDL\bLI\bIN\bNE\bE policy,  S\bSC\bCH\bHE\bED\bD_\b_D\bDE\bEA\bAD\bDL\bLI\bIN\bNE\bE  threads  are  the\r\n       highest  priority  (user  controllable)  threads  in the system; if any\r\n       S\bSC\bCH\bHE\bED\bD_\b_D\bDE\bEA\bAD\bDL\bLI\bIN\bNE\bE thread is runnable, it will preempt any thread scheduled\r\n       under one of the other policies.\r\n\r\n       A call to f\bfo\bor\brk\bk(2) by a thread scheduled under the S\bSC\bCH\bHE\bED\bD_\b_D\bDE\bEA\bAD\bDL\bLI\bIN\bNE\bE policy\r\n       fails with the error E\bEA\bAG\bGA\bAI\bIN\bN, unless the thread  has  its  reset-on-fork\r\n       flag set (see below).\r\n\r\n       A  S\bSC\bCH\bHE\bED\bD_\b_D\bDE\bEA\bAD\bDL\bLI\bIN\bNE\bE  thread that calls s\bsc\bch\bhe\bed\bd_\b_y\byi\bie\bel\bld\bd(2) will yield the cur\u2010\r\n       rent job and wait for a new period to begin.\r\n\r\n   S\bSC\bCH\bHE\bED\bD_\b_O\bOT\bTH\bHE\bER\bR:\b: D\bDe\bef\bfa\bau\bul\blt\bt L\bLi\bin\bnu\bux\bx t\bti\bim\bme\be-\b-s\bsh\bha\bar\bri\bin\bng\bg s\bsc\bch\bhe\bed\bdu\bul\bli\bin\bng\bg\r\n       S\bSC\bCH\bHE\bED\bD_\b_O\bOT\bTH\bHE\bER\bR can be used at only static priority 0 (i.e., threads  under\r\n       real-time  policies  always  have priority over S\bSC\bCH\bHE\bED\bD_\b_O\bOT\bTH\bHE\bER\bR processes).\r\n       S\bSC\bCH\bHE\bED\bD_\b_O\bOT\bTH\bHE\bER\bR is the standard Linux time-sharing scheduler  that  is  in\u2010\r\n       tended for all threads that do not require the special real-time mecha\u2010\r\n       nisms.\r\n\r\n       The thread to run is chosen from the static priority 0 list based on  a\r\n       _\bd_\by_\bn_\ba_\bm_\bi_\bc priority that is determined only inside this list.  The dynamic\r\n       priority is based on the nice value (see below) and  is  increased  for\r\n       each  time quantum the thread is ready to run, but denied to run by the\r\n       scheduler.  This ensures fair progress among all S\bSC\bCH\bHE\bED\bD_\b_O\bOT\bTH\bHE\bER\bR threads.\r\n\r\n       In the Linux kernel source code, the  S\bSC\bCH\bHE\bED\bD_\b_O\bOT\bTH\bHE\bER\bR  policy  is  actually\r\n       named S\bSC\bCH\bHE\bED\bD_\b_N\bNO\bOR\bRM\bMA\bAL\bL.\r\n\r\n   T\bTh\bhe\be n\bni\bic\bce\be v\bva\bal\blu\bue\be\r\n       The  nice  value  is an attribute that can be used to influence the CPU\r\n       scheduler to favor or disfavor a process in scheduling  decisions.   It\r\n       affects  the scheduling of S\bSC\bCH\bHE\bED\bD_\b_O\bOT\bTH\bHE\bER\bR and S\bSC\bCH\bHE\bED\bD_\b_B\bBA\bAT\bTC\bCH\bH (see below) pro\u2010\r\n       cesses.  The nice value can be modified using n\bni\bic\bce\be(2),  s\bse\bet\btp\bpr\bri\bio\bor\bri\bit\bty\by(2),\r\n       or s\bsc\bch\bhe\bed\bd_\b_s\bse\bet\bta\bat\btt\btr\br(2).\r\n\r\n       According  to  POSIX.1, the nice value is a per-process attribute; that\r\n       is, the threads in a process should share a nice  value.   However,  on\r\n       Linux,  the  nice value is a per-thread attribute: different threads in\r\n       the same process may have different nice values.\r\n\r\n       The range of the nice value varies  across  UNIX  systems.   On  modern\r\n       Linux, the range is -20 (high priority) to +19 (low priority).  On some\r\n       other systems, the range is -20..20.  Very early Linux kernels  (Before\r\n       Linux 2.0) had the range -infinity..15.\r\n\r\n       The  degree  to which the nice value affects the relative scheduling of\r\n       S\bSC\bCH\bHE\bED\bD_\b_O\bOT\bTH\bHE\bER\bR processes likewise varies across UNIX  systems  and  across\r\n       Linux kernel versions.\r\n\r\n       With the advent of the CFS scheduler in kernel 2.6.23, Linux adopted an\r\n       algorithm that causes relative differences in nice  values  to  have  a\r\n       much stronger effect.  In the current implementation, each unit of dif\u2010\r\n       ference in the nice values of two processes results in a factor of 1.25\r\n       in  the  degree  to  which  the  scheduler  favors  the higher priority\r\n       process.  This causes very low nice values (+19) to truly provide  lit\u2010\r\n       tle  CPU  to a process whenever there is any other higher priority load\r\n       on the system, and makes high nice values (-20) deliver most of the CPU\r\n       to applications that require it (e.g., some audio applications).\r\n\r\n       On  Linux, the R\bRL\bLI\bIM\bMI\bIT\bT_\b_N\bNI\bIC\bCE\bE resource limit can be used to define a limit\r\n       to which an unprivileged process's nice value can be raised; see  s\bse\bet\btr\br\u2010\b\u2010\r\n       l\bli\bim\bmi\bit\bt(2) for details.\r\n\r\n       For further details on the nice value, see the subsections on the auto\u2010\r\n       group feature and group scheduling, below.\r\n\r\n   S\bSC\bCH\bHE\bED\bD_\b_B\bBA\bAT\bTC\bCH\bH:\b: S\bSc\bch\bhe\bed\bdu\bul\bli\bin\bng\bg b\bba\bat\btc\bch\bh p\bpr\bro\boc\bce\bes\bss\bse\bes\bs\r\n       (Since Linux 2.6.16.)  S\bSC\bCH\bHE\bED\bD_\b_B\bBA\bAT\bTC\bCH\bH can be used only at static  priority\r\n       0.   This  policy  is  similar  to S\bSC\bCH\bHE\bED\bD_\b_O\bOT\bTH\bHE\bER\bR in that it schedules the\r\n       thread according to its dynamic priority (based  on  the  nice  value).\r\n       The  difference  is that this policy will cause the scheduler to always\r\n       assume that the thread is CPU-intensive.  Consequently,  the  scheduler\r\n       will  apply a small scheduling penalty with respect to wakeup behavior,\r\n       so that this thread is mildly disfavored in scheduling decisions.\r\n\r\n       This policy is useful for workloads that are noninteractive, but do not\r\n       want to lower their nice value, and for workloads that want a determin\u2010\r\n       istic scheduling policy without interactivity causing extra preemptions\r\n       (between the workload's tasks).\r\n\r\n   S\bSC\bCH\bHE\bED\bD_\b_I\bID\bDL\bLE\bE:\b: S\bSc\bch\bhe\bed\bdu\bul\bli\bin\bng\bg v\bve\ber\bry\by l\blo\bow\bw p\bpr\bri\bio\bor\bri\bit\bty\by j\bjo\bob\bbs\bs\r\n       (Since  Linux  2.6.23.)  S\bSC\bCH\bHE\bED\bD_\b_I\bID\bDL\bLE\bE can be used only at static priority\r\n       0; the process nice value has no influence for this policy.\r\n\r\n       This policy is intended for running  jobs  at  extremely  low  priority\r\n       (lower  even  than a +19 nice value with the S\bSC\bCH\bHE\bED\bD_\b_O\bOT\bTH\bHE\bER\bR or S\bSC\bCH\bHE\bED\bD_\b_B\bBA\bAT\bTC\bCH\bH\r\n       policies).\r\n\r\n   R\bRe\bes\bse\bet\btt\bti\bin\bng\bg s\bsc\bch\bhe\bed\bdu\bul\bli\bin\bng\bg p\bpo\bol\bli\bic\bcy\by f\bfo\bor\br c\bch\bhi\bil\bld\bd p\bpr\bro\boc\bce\bes\bss\bse\bes\bs\r\n       Each thread has a reset-on-fork scheduling flag.   When  this  flag  is\r\n       set,  children  created by f\bfo\bor\brk\bk(2) do not inherit privileged scheduling\r\n       policies.  The reset-on-fork flag can be set by either:\r\n\r\n       *  ORing the S\bSC\bCH\bHE\bED\bD_\b_R\bRE\bES\bSE\bET\bT_\b_O\bON\bN_\b_F\bFO\bOR\bRK\bK flag into  the  _\bp_\bo_\bl_\bi_\bc_\by  argument  when\r\n          calling s\bsc\bch\bhe\bed\bd_\b_s\bse\bet\bts\bsc\bch\bhe\bed\bdu\bul\ble\ber\br(2) (since Linux 2.6.32); or\r\n\r\n       *  specifying  the  S\bSC\bCH\bHE\bED\bD_\b_F\bFL\bLA\bAG\bG_\b_R\bRE\bES\bSE\bET\bT_\b_O\bON\bN_\b_F\bFO\bOR\bRK\bK  flag  in _\ba_\bt_\bt_\br_\b._\bs_\bc_\bh_\be_\bd_\b__\bf_\bl_\ba_\bg_\bs\r\n          when calling s\bsc\bch\bhe\bed\bd_\b_s\bse\bet\bta\bat\btt\btr\br(2).\r\n\r\n       Note that the constants used with these two APIs have different  names.\r\n       The  state of the reset-on-fork flag can analogously be retrieved using\r\n       s\bsc\bch\bhe\bed\bd_\b_g\bge\bet\bts\bsc\bch\bhe\bed\bdu\bul\ble\ber\br(2) and s\bsc\bch\bhe\bed\bd_\b_g\bge\bet\bta\bat\btt\btr\br(2).\r\n\r\n       The reset-on-fork feature is intended for media-playback  applications,\r\n       and  can  be used to prevent applications evading the R\bRL\bLI\bIM\bMI\bIT\bT_\b_R\bRT\bTT\bTI\bIM\bME\bE re\u2010\r\n       source limit (see g\bge\bet\btr\brl\bli\bim\bmi\bit\bt(2)) by creating multiple child processes.\r\n\r\n       More precisely, if the reset-on-fork flag is set, the  following  rules\r\n       apply for subsequently created children:\r\n\r\n       *  If  the  calling  thread  has  a  scheduling policy of S\bSC\bCH\bHE\bED\bD_\b_F\bFI\bIF\bFO\bO or\r\n          S\bSC\bCH\bHE\bED\bD_\b_R\bRR\bR, the policy is reset to S\bSC\bCH\bHE\bED\bD_\b_O\bOT\bTH\bHE\bER\bR in child processes.\r\n\r\n       *  If the calling process has a negative nice value, the nice value  is\r\n          reset to zero in child processes.\r\n\r\n       After  the reset-on-fork flag has been enabled, it can be reset only if\r\n       the thread has the C\bCA\bAP\bP_\b_S\bSY\bYS\bS_\b_N\bNI\bIC\bCE\bE capability.  This flag is  disabled  in\r\n       child processes created by f\bfo\bor\brk\bk(2).\r\n\r\n   P\bPr\bri\biv\bvi\bil\ble\beg\bge\bes\bs a\ban\bnd\bd r\bre\bes\bso\bou\bur\brc\bce\be l\bli\bim\bmi\bit\bts\bs\r\n       In  Linux kernels before 2.6.12, only privileged (C\bCA\bAP\bP_\b_S\bSY\bYS\bS_\b_N\bNI\bIC\bCE\bE) threads\r\n       can set a nonzero static priority (i.e.,  set  a  real-time  scheduling\r\n       policy).   The  only  change that an unprivileged thread can make is to\r\n       set the S\bSC\bCH\bHE\bED\bD_\b_O\bOT\bTH\bHE\bER\bR policy, and this can be done only if the  effective\r\n       user ID of the caller matches the real or effective user ID of the tar\u2010\r\n       get thread (i.e., the thread specified by _\bp_\bi_\bd) whose  policy  is  being\r\n       changed.\r\n\r\n       A  thread must be privileged (C\bCA\bAP\bP_\b_S\bSY\bYS\bS_\b_N\bNI\bIC\bCE\bE) in order to set or modify a\r\n       S\bSC\bCH\bHE\bED\bD_\b_D\bDE\bEA\bAD\bDL\bLI\bIN\bNE\bE policy.\r\n\r\n       Since Linux 2.6.12, the R\bRL\bLI\bIM\bMI\bIT\bT_\b_R\bRT\bTP\bPR\bRI\bIO\bO resource limit defines a  ceiling\r\n       on  an  unprivileged  thread's  static  priority  for  the S\bSC\bCH\bHE\bED\bD_\b_R\bRR\bR and\r\n       S\bSC\bCH\bHE\bED\bD_\b_F\bFI\bIF\bFO\bO policies.  The rules for changing scheduling policy and pri\u2010\r\n       ority are as follows:\r\n\r\n       *  If  an  unprivileged  thread has a nonzero R\bRL\bLI\bIM\bMI\bIT\bT_\b_R\bRT\bTP\bPR\bRI\bIO\bO soft limit,\r\n          then it can change its scheduling policy and  priority,  subject  to\r\n          the  restriction  that  the priority cannot be set to a value higher\r\n          than the maximum of its current priority and its R\bRL\bLI\bIM\bMI\bIT\bT_\b_R\bRT\bTP\bPR\bRI\bIO\bO  soft\r\n          limit.\r\n\r\n       *  If  the  R\bRL\bLI\bIM\bMI\bIT\bT_\b_R\bRT\bTP\bPR\bRI\bIO\bO  soft  limit  is  0,  then the only permitted\r\n          changes are to lower the priority, or to switch to  a  non-real-time\r\n          policy.\r\n\r\n       *  Subject to the same rules, another unprivileged thread can also make\r\n          these changes, as long as the effective user ID of the thread making\r\n          the  change  matches  the  real  or  effective user ID of the target\r\n          thread.\r\n\r\n       *  Special rules apply for the S\bSC\bCH\bHE\bED\bD_\b_I\bID\bDL\bLE\bE policy.  In Linux kernels be\u2010\r\n          fore 2.6.39, an unprivileged thread operating under this policy can\u2010\r\n          not change its policy, regardless of the value of its  R\bRL\bLI\bIM\bMI\bIT\bT_\b_R\bRT\bTP\bPR\bRI\bIO\bO\r\n          resource  limit.   In  Linux  kernels  since 2.6.39, an unprivileged\r\n          thread can switch to either the S\bSC\bCH\bHE\bED\bD_\b_B\bBA\bAT\bTC\bCH\bH or the S\bSC\bCH\bHE\bED\bD_\b_O\bOT\bTH\bHE\bER\bR  pol\u2010\r\n          icy  so  long  as its nice value falls within the range permitted by\r\n          its R\bRL\bLI\bIM\bMI\bIT\bT_\b_N\bNI\bIC\bCE\bE resource limit (see g\bge\bet\btr\brl\bli\bim\bmi\bit\bt(2)).\r\n\r\n       Privileged (C\bCA\bAP\bP_\b_S\bSY\bYS\bS_\b_N\bNI\bIC\bCE\bE) threads ignore the  R\bRL\bLI\bIM\bMI\bIT\bT_\b_R\bRT\bTP\bPR\bRI\bIO\bO  limit;  as\r\n       with  older kernels, they can make arbitrary changes to scheduling pol\u2010\r\n       icy  and  priority.   See  g\bge\bet\btr\brl\bli\bim\bmi\bit\bt(2)  for  further  information   on\r\n       R\bRL\bLI\bIM\bMI\bIT\bT_\b_R\bRT\bTP\bPR\bRI\bIO\bO.\r\n\r\n   L\bLi\bim\bmi\bit\bti\bin\bng\bg t\bth\bhe\be C\bCP\bPU\bU u\bus\bsa\bag\bge\be o\bof\bf r\bre\bea\bal\bl-\b-t\bti\bim\bme\be a\ban\bnd\bd d\bde\bea\bad\bdl\bli\bin\bne\be p\bpr\bro\boc\bce\bes\bss\bse\bes\bs\r\n       A nonblocking infinite loop in a thread scheduled under the S\bSC\bCH\bHE\bED\bD_\b_F\bFI\bIF\bFO\bO,\r\n       S\bSC\bCH\bHE\bED\bD_\b_R\bRR\bR, or S\bSC\bCH\bHE\bED\bD_\b_D\bDE\bEA\bAD\bDL\bLI\bIN\bNE\bE policy  can  potentially  block  all  other\r\n       threads  from  accessing  the  CPU forever.  Prior to Linux 2.6.25, the\r\n       only way of preventing a runaway real-time process  from  freezing  the\r\n       system  was  to  run  (at the console) a shell scheduled under a higher\r\n       static priority than the tested application.  This allows an  emergency\r\n       kill of tested real-time applications that do not block or terminate as\r\n       expected.\r\n\r\n       Since Linux 2.6.25, there are other techniques for dealing with runaway\r\n       real-time  and  deadline  processes.   One  of  these  is  to  use  the\r\n       R\bRL\bLI\bIM\bMI\bIT\bT_\b_R\bRT\bTT\bTI\bIM\bME\bE resource limit to set a ceiling on the CPU  time  that  a\r\n       real-time process may consume.  See g\bge\bet\btr\brl\bli\bim\bmi\bit\bt(2) for details.\r\n\r\n       Since  version  2.6.25, Linux also provides two _\b/_\bp_\br_\bo_\bc files that can be\r\n       used to reserve a certain amount of CPU time to be  used  by  non-real-\r\n       time  processes.   Reserving  CPU  time in this fashion allows some CPU\r\n       time to be allocated to (say) a root shell that can be used to  kill  a\r\n       runaway  process.  Both of these files specify time values in microsec\u2010\r\n       onds:\r\n\r\n       _\b/_\bp_\br_\bo_\bc_\b/_\bs_\by_\bs_\b/_\bk_\be_\br_\bn_\be_\bl_\b/_\bs_\bc_\bh_\be_\bd_\b__\br_\bt_\b__\bp_\be_\br_\bi_\bo_\bd_\b__\bu_\bs\r\n              This file specifies a scheduling period that  is  equivalent  to\r\n              100%  CPU bandwidth.  The value in this file can range from 1 to\r\n              I\bIN\bNT\bT_\b_M\bMA\bAX\bX, giving an operating range of 1 microsecond to around 35\r\n              minutes.   The  default  value in this file is 1,000,000 (1 sec\u2010\r\n              ond).\r\n\r\n       _\b/_\bp_\br_\bo_\bc_\b/_\bs_\by_\bs_\b/_\bk_\be_\br_\bn_\be_\bl_\b/_\bs_\bc_\bh_\be_\bd_\b__\br_\bt_\b__\br_\bu_\bn_\bt_\bi_\bm_\be_\b__\bu_\bs\r\n              The value in this file specifies how much of the  \"period\"  time\r\n              can be used by all real-time and deadline scheduled processes on\r\n              the system.  The value  in  this  file  can  range  from  -1  to\r\n              I\bIN\bNT\bT_\b_M\bMA\bAX\bX-1.  Specifying -1 makes the run time the same as the pe\u2010\r\n              riod; that is, no CPU time is set aside for  non-real-time  pro\u2010\r\n              cesses (which was the Linux behavior before kernel 2.6.25).  The\r\n              default value in this file is 950,000  (0.95  seconds),  meaning\r\n              that 5% of the CPU time is reserved for processes that don't run\r\n              under a real-time or deadline scheduling policy.\r\n\r\n   R\bRe\bes\bsp\bpo\bon\bns\bse\be t\bti\bim\bme\be\r\n       A blocked high priority thread waiting for I/O has a  certain  response\r\n       time  before  it  is  scheduled  again.   The  device driver writer can\r\n       greatly reduce this response time by using a \"slow interrupt\" interrupt\r\n       handler.\r\n\r\n   M\bMi\bis\bsc\bce\bel\bll\bla\ban\bne\beo\bou\bus\bs\r\n       Child  processes  inherit the scheduling policy and parameters across a\r\n       f\bfo\bor\brk\bk(2).  The scheduling policy and parameters are preserved across e\bex\bx\u2010\b\u2010\r\n       e\bec\bcv\bve\be(2).\r\n\r\n       Memory  locking is usually needed for real-time processes to avoid pag\u2010\r\n       ing delays; this can be done with m\bml\blo\boc\bck\bk(2) or m\bml\blo\boc\bck\bka\bal\bll\bl(2).\r\n\r\n   T\bTh\bhe\be a\bau\but\bto\bog\bgr\bro\bou\bup\bp f\bfe\bea\bat\btu\bur\bre\be\r\n       Since Linux 2.6.38, the kernel provides a feature known as autogrouping\r\n       to improve interactive desktop performance in the face of multiprocess,\r\n       CPU-intensive workloads such as building the Linux  kernel  with  large\r\n       numbers of parallel build processes (i.e., the m\bma\bak\bke\be(1) -\b-j\bj flag).\r\n\r\n       This  feature  operates  in  conjunction with the CFS scheduler and re\u2010\r\n       quires a kernel that is configured with C\bCO\bON\bNF\bFI\bIG\bG_\b_S\bSC\bCH\bHE\bED\bD_\b_A\bAU\bUT\bTO\bOG\bGR\bRO\bOU\bUP\bP.   On  a\r\n       running  system,  this  feature  is  enabled  or  disabled via the file\r\n       _\b/_\bp_\br_\bo_\bc_\b/_\bs_\by_\bs_\b/_\bk_\be_\br_\bn_\be_\bl_\b/_\bs_\bc_\bh_\be_\bd_\b__\ba_\bu_\bt_\bo_\bg_\br_\bo_\bu_\bp_\b__\be_\bn_\ba_\bb_\bl_\be_\bd; a value  of  0  disables  the\r\n       feature, while a value of 1 enables it.  The default value in this file\r\n       is 1, unless the kernel was booted with the _\bn_\bo_\ba_\bu_\bt_\bo_\bg_\br_\bo_\bu_\bp parameter.\r\n\r\n       A new autogroup is created when a new session is created via s\bse\bet\bts\bsi\bid\bd(2);\r\n       this  happens,  for  example, when a new terminal window is started.  A\r\n       new process created by f\bfo\bor\brk\bk(2) inherits its parent's autogroup  member\u2010\r\n       ship.   Thus, all of the processes in a session are members of the same\r\n       autogroup.  An autogroup  is  automatically  destroyed  when  the  last\r\n       process in the group terminates.\r\n\r\n       When  autogrouping  is  enabled, all of the members of an autogroup are\r\n       placed in the same kernel scheduler \"task group\".   The  CFS  scheduler\r\n       employs  an  algorithm  that  equalizes  the distribution of CPU cycles\r\n       across task groups.  The benefits of this for interactive desktop  per\u2010\r\n       formance can be described via the following example.\r\n\r\n       Suppose that there are two autogroups competing for the same CPU (i.e.,\r\n       presume either a single CPU system or the use of t\bta\bas\bsk\bks\bse\bet\bt(1) to  confine\r\n       all  the  processes to the same CPU on an SMP system).  The first group\r\n       contains ten CPU-bound processes  from  a  kernel  build  started  with\r\n       _\bm_\ba_\bk_\be _\b-_\bj_\b1_\b0.   The  other  contains  a  single CPU-bound process: a video\r\n       player.  The effect of autogrouping is that the two  groups  will  each\r\n       receive half of the CPU cycles.  That is, the video player will receive\r\n       50% of the CPU cycles, rather than just 9% of the cycles,  which  would\r\n       likely lead to degraded video playback.  The situation on an SMP system\r\n       is more complex, but the general effect is the same: the scheduler dis\u2010\r\n       tributes CPU cycles across task groups such that an autogroup that con\u2010\r\n       tains a large number of CPU-bound processes does not end up hogging CPU\r\n       cycles at the expense of the other jobs on the system.\r\n\r\n       A  process's  autogroup  (task  group) membership can be viewed via the\r\n       file _\b/_\bp_\br_\bo_\bc_\b/_\b[_\bp_\bi_\bd_\b]_\b/_\ba_\bu_\bt_\bo_\bg_\br_\bo_\bu_\bp:\r\n\r\n           $ c\bca\bat\bt /\b/p\bpr\bro\boc\bc/\b/1\b1/\b/a\bau\but\bto\bog\bgr\bro\bou\bup\bp\r\n           /autogroup-1 nice 0\r\n\r\n       This file can also be used to modify the CPU bandwidth allocated to  an\r\n       autogroup.  This is done by writing a number in the \"nice\" range to the\r\n       file to set the autogroup's nice value.  The allowed range is from  +19\r\n       (low priority) to -20 (high priority).  (Writing values outside of this\r\n       range causes w\bwr\bri\bit\bte\be(2) to fail with the error E\bEI\bIN\bNV\bVA\bAL\bL.)\r\n\r\n       The autogroup nice setting has the same meaning  as  the  process  nice\r\n       value,  but applies to distribution of CPU cycles to the autogroup as a\r\n       whole, based on the relative nice values of other  autogroups.   For  a\r\n       process  inside an autogroup, the CPU cycles that it receives will be a\r\n       product of the autogroup's nice value (compared  to  other  autogroups)\r\n       and  the  process's nice value (compared to other processes in the same\r\n       autogroup.\r\n\r\n       The use of the c\bcg\bgr\bro\bou\bup\bps\bs(7) CPU controller to place processes in  cgroups\r\n       other than the root CPU cgroup overrides the effect of autogrouping.\r\n\r\n       The  autogroup  feature groups only processes scheduled under non-real-\r\n       time policies (S\bSC\bCH\bHE\bED\bD_\b_O\bOT\bTH\bHE\bER\bR, S\bSC\bCH\bHE\bED\bD_\b_B\bBA\bAT\bTC\bCH\bH, and S\bSC\bCH\bHE\bED\bD_\b_I\bID\bDL\bLE\bE).  It does  not\r\n       group processes scheduled under real-time and deadline policies.  Those\r\n       processes are scheduled according to the rules described earlier.\r\n\r\n   T\bTh\bhe\be n\bni\bic\bce\be v\bva\bal\blu\bue\be a\ban\bnd\bd g\bgr\bro\bou\bup\bp s\bsc\bch\bhe\bed\bdu\bul\bli\bin\bng\bg\r\n       When scheduling non-real-time processes (i.e.,  those  scheduled  under\r\n       the  S\bSC\bCH\bHE\bED\bD_\b_O\bOT\bTH\bHE\bER\bR, S\bSC\bCH\bHE\bED\bD_\b_B\bBA\bAT\bTC\bCH\bH, and S\bSC\bCH\bHE\bED\bD_\b_I\bID\bDL\bLE\bE policies), the CFS sched\u2010\r\n       uler employs a technique known as \"group scheduling\", if the kernel was\r\n       configured with the C\bCO\bON\bNF\bFI\bIG\bG_\b_F\bFA\bAI\bIR\bR_\b_G\bGR\bRO\bOU\bUP\bP_\b_S\bSC\bCH\bHE\bED\bD option (which is typical).\r\n\r\n       Under  group  scheduling, threads are scheduled in \"task groups\".  Task\r\n       groups have a hierarchical relationship, rooted under the initial  task\r\n       group  on  the system, known as the \"root task group\".  Task groups are\r\n       formed in the following circumstances:\r\n\r\n       *  All of the threads in a CPU cgroup form a task group.  The parent of\r\n          this  task  group  is  the  task  group  of the corresponding parent\r\n          cgroup.\r\n\r\n       *  If autogrouping is enabled, then all of the threads  that  are  (im\u2010\r\n          plicitly) placed in an autogroup (i.e., the same session, as created\r\n          by s\bse\bet\bts\bsi\bid\bd(2)) form a task group.  Each new autogroup is thus a sepa\u2010\r\n          rate  task group.  The root task group is the parent of all such au\u2010\r\n          togroups.\r\n\r\n       *  If autogrouping is enabled, then the root task group consists of all\r\n          processes  in the root CPU cgroup that were not otherwise implicitly\r\n          placed into a new autogroup.\r\n\r\n       *  If autogrouping is disabled, then the root task  group  consists  of\r\n          all processes in the root CPU cgroup.\r\n\r\n       *  If  group  scheduling  was disabled (i.e., the kernel was configured\r\n          without C\bCO\bON\bNF\bFI\bIG\bG_\b_F\bFA\bAI\bIR\bR_\b_G\bGR\bRO\bOU\bUP\bP_\b_S\bSC\bCH\bHE\bED\bD), then all of the processes  on  the\r\n          system are notionally placed in a single task group.\r\n\r\n       Under  group scheduling, a thread's nice value has an effect for sched\u2010\r\n       uling decisions _\bo_\bn_\bl_\by _\br_\be_\bl_\ba_\bt_\bi_\bv_\be _\bt_\bo _\bo_\bt_\bh_\be_\br _\bt_\bh_\br_\be_\ba_\bd_\bs _\bi_\bn _\bt_\bh_\be _\bs_\ba_\bm_\be _\bt_\ba_\bs_\bk  _\bg_\br_\bo_\bu_\bp.\r\n       This  has  some surprising consequences in terms of the traditional se\u2010\r\n       mantics of the nice value on UNIX systems.   In  particular,  if  auto\u2010\r\n       grouping  is  enabled  (which is the default in various distributions),\r\n       then employing s\bse\bet\btp\bpr\bri\bio\bor\bri\bit\bty\by(2) or n\bni\bic\bce\be(1) on a  process  has  an  effect\r\n       only  for  scheduling  relative to other processes executed in the same\r\n       session (typically: the same terminal window).\r\n\r\n       Conversely, for two processes that are (for example) the sole CPU-bound\r\n       processes in different sessions (e.g., different terminal windows, each\r\n       of whose jobs are tied to different  autogroups),  _\bm_\bo_\bd_\bi_\bf_\by_\bi_\bn_\bg  _\bt_\bh_\be  _\bn_\bi_\bc_\be\r\n       _\bv_\ba_\bl_\bu_\be  _\bo_\bf  _\bt_\bh_\be _\bp_\br_\bo_\bc_\be_\bs_\bs _\bi_\bn _\bo_\bn_\be _\bo_\bf _\bt_\bh_\be _\bs_\be_\bs_\bs_\bi_\bo_\bn_\bs _\bh_\ba_\bs _\bn_\bo _\be_\bf_\bf_\be_\bc_\bt in terms of\r\n       the scheduler's decisions relative to the process in the other session.\r\n       A  possibly useful workaround here is to use a command such as the fol\u2010\r\n       lowing to modify the autogroup nice value for _\ba_\bl_\bl of the processes in a\r\n       terminal session:\r\n\r\n           $ e\bec\bch\bho\bo 1\b10\b0 >\b> /\b/p\bpr\bro\boc\bc/\b/s\bse\bel\blf\bf/\b/a\bau\but\bto\bog\bgr\bro\bou\bup\bp\r\n\r\n   R\bRe\bea\bal\bl-\b-t\bti\bim\bme\be f\bfe\bea\bat\btu\bur\bre\bes\bs i\bin\bn t\bth\bhe\be m\bma\bai\bin\bnl\bli\bin\bne\be L\bLi\bin\bnu\bux\bx k\bke\ber\brn\bne\bel\bl\r\n       Since  kernel version 2.6.18, Linux is gradually becoming equipped with\r\n       real-time capabilities, most of which are derived from the former _\br_\be_\ba_\bl_\b\u2010\r\n       _\bt_\bi_\bm_\be_\b-_\bp_\br_\be_\be_\bm_\bp_\bt  patch set.  Until the patches have been completely merged\r\n       into the mainline kernel, they must be installed to  achieve  the  best\r\n       real-time performance.  These patches are named:\r\n\r\n           patch-_\bk_\be_\br_\bn_\be_\bl_\bv_\be_\br_\bs_\bi_\bo_\bn-rt_\bp_\ba_\bt_\bc_\bh_\bv_\be_\br_\bs_\bi_\bo_\bn\r\n\r\n       and  can  be  downloaded  from  \u27e8http://www.kernel.org/pub/linux/kernel\r\n       /projects/rt/\u27e9.\r\n\r\n       Without the patches and prior to their full inclusion into the mainline\r\n       kernel,  the  kernel  configuration  offers  only  the three preemption\r\n       classes C\bCO\bON\bNF\bFI\bIG\bG_\b_P\bPR\bRE\bEE\bEM\bMP\bPT\bT_\b_N\bNO\bON\bNE\bE, C\bCO\bON\bNF\bFI\bIG\bG_\b_P\bPR\bRE\bEE\bEM\bMP\bPT\bT_\b_V\bVO\bOL\bLU\bUN\bNT\bTA\bAR\bRY\bY, and  C\bCO\bON\bNF\bFI\bIG\bG_\b_P\bPR\bRE\bE\u2010\b\u2010\r\n       E\bEM\bMP\bPT\bT_\b_D\bDE\bES\bSK\bKT\bTO\bOP\bP  which respectively provide no, some, and considerable re\u2010\r\n       duction of the worst-case scheduling latency.\r\n\r\n       With the patches applied or after their full inclusion into  the  main\u2010\r\n       line  kernel,  the  additional configuration item C\bCO\bON\bNF\bFI\bIG\bG_\b_P\bPR\bRE\bEE\bEM\bMP\bPT\bT_\b_R\bRT\bT be\u2010\r\n       comes available.  If this is selected, Linux is transformed into a reg\u2010\r\n       ular  real-time  operating system.  The FIFO and RR scheduling policies\r\n       are then used to run a thread with true real-time priority and a  mini\u2010\r\n       mum worst-case scheduling latency.\r\n\r\nN\bNO\bOT\bTE\bES\bS\r\n       The  c\bcg\bgr\bro\bou\bup\bps\bs(7) CPU controller can be used to limit the CPU consumption\r\n       of groups of processes.\r\n\r\n       Originally, Standard Linux was intended as a general-purpose  operating\r\n       system  being able to handle background processes, interactive applica\u2010\r\n       tions, and less demanding  real-time  applications  (applications  that\r\n       need  to usually meet timing deadlines).  Although the Linux kernel 2.6\r\n       allowed for kernel preemption and the newly introduced  O(1)  scheduler\r\n       ensures that the time needed to schedule is fixed and deterministic ir\u2010\r\n       respective of the number of active tasks, true real-time computing  was\r\n       not possible up to kernel version 2.6.17.\r\n\r\nS\bSE\bEE\bE A\bAL\bLS\bSO\bO\r\n       c\bch\bhc\bcp\bpu\bu(1), c\bch\bhr\brt\bt(1), l\bls\bsc\bcp\bpu\bu(1), p\bps\bs(1), t\bta\bas\bsk\bks\bse\bet\bt(1), t\bto\bop\bp(1), g\bge\bet\btp\bpr\bri\bio\bor\bri\bit\bty\by(2),\r\n       m\bml\blo\boc\bck\bk(2), m\bml\blo\boc\bck\bka\bal\bll\bl(2), m\bmu\bun\bnl\blo\boc\bck\bk(2), m\bmu\bun\bnl\blo\boc\bck\bka\bal\bll\bl(2), n\bni\bic\bce\be(2),\r\n       s\bsc\bch\bhe\bed\bd_\b_g\bge\bet\bt_\b_p\bpr\bri\bio\bor\bri\bit\bty\by_\b_m\bma\bax\bx(2), s\bsc\bch\bhe\bed\bd_\b_g\bge\bet\bt_\b_p\bpr\bri\bio\bor\bri\bit\bty\by_\b_m\bmi\bin\bn(2),\r\n       s\bsc\bch\bhe\bed\bd_\b_g\bge\bet\bta\baf\bff\bfi\bin\bni\bit\bty\by(2), s\bsc\bch\bhe\bed\bd_\b_g\bge\bet\btp\bpa\bar\bra\bam\bm(2), s\bsc\bch\bhe\bed\bd_\b_g\bge\bet\bts\bsc\bch\bhe\bed\bdu\bul\ble\ber\br(2),\r\n       s\bsc\bch\bhe\bed\bd_\b_r\brr\br_\b_g\bge\bet\bt_\b_i\bin\bnt\bte\ber\brv\bva\bal\bl(2), s\bsc\bch\bhe\bed\bd_\b_s\bse\bet\bta\baf\bff\bfi\bin\bni\bit\bty\by(2), s\bsc\bch\bhe\bed\bd_\b_s\bse\bet\btp\bpa\bar\bra\bam\bm(2),\r\n       s\bsc\bch\bhe\bed\bd_\b_s\bse\bet\bts\bsc\bch\bhe\bed\bdu\bul\ble\ber\br(2), s\bsc\bch\bhe\bed\bd_\b_y\byi\bie\bel\bld\bd(2), s\bse\bet\btp\bpr\bri\bio\bor\bri\bit\bty\by(2),\r\n       p\bpt\bth\bhr\bre\bea\bad\bd_\b_g\bge\bet\bta\baf\bff\bfi\bin\bni\bit\bty\by_\b_n\bnp\bp(3), p\bpt\bth\bhr\bre\bea\bad\bd_\b_g\bge\bet\bts\bsc\bch\bhe\bed\bdp\bpa\bar\bra\bam\bm(3),\r\n       p\bpt\bth\bhr\bre\bea\bad\bd_\b_s\bse\bet\bta\baf\bff\bfi\bin\bni\bit\bty\by_\b_n\bnp\bp(3), s\bsc\bch\bhe\bed\bd_\b_g\bge\bet\btc\bcp\bpu\bu(3), c\bca\bap\bpa\bab\bbi\bil\bli\bit\bti\bie\bes\bs(7), c\bcp\bpu\bus\bse\bet\bt(7)\r\n\r\n       _\bP_\br_\bo_\bg_\br_\ba_\bm_\bm_\bi_\bn_\bg _\bf_\bo_\br _\bt_\bh_\be _\br_\be_\ba_\bl  _\bw_\bo_\br_\bl_\bd  _\b-  _\bP_\bO_\bS_\bI_\bX_\b._\b4  by  Bill  O.  Gallmeister,\r\n       O'Reilly & Associates, Inc., ISBN 1-56592-074-0.\r\n\r\n       The    Linux   kernel   source   files   _\bD_\bo_\bc_\bu_\bm_\be_\bn_\bt_\ba_\bt_\bi_\bo_\bn_\b/_\bs_\bc_\bh_\be_\bd_\bu_\bl_\be_\br_\b/_\bs_\bc_\bh_\be_\bd_\b-\r\n       _\bd_\be_\ba_\bd_\bl_\bi_\bn_\be_\b._\bt_\bx_\bt,               _\bD_\bo_\bc_\bu_\bm_\be_\bn_\bt_\ba_\bt_\bi_\bo_\bn_\b/_\bs_\bc_\bh_\be_\bd_\bu_\bl_\be_\br_\b/_\bs_\bc_\bh_\be_\bd_\b-_\br_\bt_\b-_\bg_\br_\bo_\bu_\bp_\b._\bt_\bx_\bt,\r\n       _\bD_\bo_\bc_\bu_\bm_\be_\bn_\bt_\ba_\bt_\bi_\bo_\bn_\b/_\bs_\bc_\bh_\be_\bd_\bu_\bl_\be_\br_\b/_\bs_\bc_\bh_\be_\bd_\b-_\bd_\be_\bs_\bi_\bg_\bn_\b-_\bC_\bF_\bS_\b._\bt_\bx_\bt,                       and\r\n       _\bD_\bo_\bc_\bu_\bm_\be_\bn_\bt_\ba_\bt_\bi_\bo_\bn_\b/_\bs_\bc_\bh_\be_\bd_\bu_\bl_\be_\br_\b/_\bs_\bc_\bh_\be_\bd_\b-_\bn_\bi_\bc_\be_\b-_\bd_\be_\bs_\bi_\bg_\bn_\b._\bt_\bx_\bt\r\n\r\nC\bCO\bOL\bLO\bOP\bPH\bHO\bON\bN\r\n       This page is part of release 5.05 of the Linux  _\bm_\ba_\bn_\b-_\bp_\ba_\bg_\be_\bs  project.   A\r\n       description  of  the project, information about reporting bugs, and the\r\n       latest    version    of    this    page,    can     be     found     at\r\n       https://www.kernel.org/doc/man-pages/.\r\n\r\nLinux                             2019-08-02                          SCHED(7)\r\n$ "}]}}, "3d821f0bfe9541d8b4b959cc6a27e981": {"model_module": "@jupyter-widgets/base", "model_module_version": "1.2.0", "model_name": "LayoutModel", "state": {"_model_module": "@jupyter-widgets/base", "_model_module_version": "1.2.0", "_model_name": "LayoutModel", "_view_count": null, "_view_module": "@jupyter-widgets/base", "_view_module_version": "1.2.0", "_view_name": "LayoutView", "align_content": null, "align_items": null, "align_self": null, "border": "1px solid black", "bottom": null, "display": null, "flex": null, "flex_flow": null, "grid_area": null, "grid_auto_columns": null, "grid_auto_flow": null, "grid_auto_rows": null, "grid_column": null, "grid_gap": null, "grid_row": null, "grid_template_areas": null, "grid_template_columns": null, "grid_template_rows": null, "height": "2in", "justify_content": null, "justify_items": null, "left": null, "margin": null, "max_height": null, "max_width": null, "min_height": null, "min_width": null, "object_fit": null, "object_position": null, "order": null, "overflow": null, "overflow_x": null, "overflow_y": "scroll", "padding": null, "right": null, "top": null, "visibility": null, "width": null}}}, "version_major": 2, "version_minor": 0}
</script>


    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./scheduling"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="sch-prio.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title"><span class="section-number">10.3. </span>Scheduling with Priorities</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="review.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">11. </span>Review Questions</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By (see contributing chapter book)<br/>
  
      &copy; Copyright 2022.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>