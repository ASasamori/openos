
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

    <title>23. Overview of MM &#8212; Introduction to Operating Systems</title>
    
  <!-- Loaded before other Sphinx assets -->
  <link href="../_static/styles/theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">
<link href="../_static/styles/pydata-sphinx-theme.css?digest=1999514e3f237ded88cf" rel="stylesheet">

    
  <link rel="stylesheet"
    href="../_static/vendor/fontawesome/5.13.0/css/all.min.css">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-solid-900.woff2">
  <link rel="preload" as="font" type="font/woff2" crossorigin
    href="../_static/vendor/fontawesome/5.13.0/webfonts/fa-brands-400.woff2">

    <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
    <link rel="stylesheet" href="../_static/styles/sphinx-book-theme.css?digest=5115cc725059bd94278eecd172e13a965bf8f5a9" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/togglebutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/copybutton.css" />
    <link rel="stylesheet" type="text/css" href="../_static/mystnb.css" />
    <link rel="stylesheet" type="text/css" href="../_static/sphinx-thebe.css" />
    <link rel="stylesheet" type="text/css" href="../_static/design-style.b7bb847fb20b106c3d81b95245e65545.min.css" />
    
  <!-- Pre-loaded scripts that we'll load fully later -->
  <link rel="preload" as="script" href="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf">

    <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/clipboard.min.js"></script>
    <script src="../_static/copybutton.js"></script>
    <script src="../_static/scripts/sphinx-book-theme.js?digest=9c920249402e914e316237a7dbc6769907cce411"></script>
    <script>let toggleHintShow = 'Click to show';</script>
    <script>let toggleHintHide = 'Click to hide';</script>
    <script>let toggleOpenOnPrint = 'true';</script>
    <script src="../_static/togglebutton.js"></script>
    <script async="async" kind="hypothesis" src="https://hypothes.is/embed.js"></script>
    <script>var togglebuttonSelector = '.toggle, .admonition.dropdown, .tag_hide_input div.cell_input, .tag_hide-input div.cell_input, .tag_hide_output div.cell_output, .tag_hide-output div.cell_output, .tag_hide_cell.cell, .tag_hide-cell.cell';</script>
    <script src="../_static/design-tabs.js"></script>
    <script>const THEBE_JS_URL = "https://unpkg.com/thebe@0.8.2/lib/index.js"
const thebe_selector = ".thebe,.cell"
const thebe_selector_input = "pre"
const thebe_selector_output = ".output, .cell_output"
</script>
    <script async="async" src="../_static/sphinx-thebe.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.20.1/dist/embed-amd.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="24. Peter’s Virtual Memory chapter" href="peter-mm.html" />
    <link rel="prev" title="21. EVERYTHING BELOW HERE IS CRAP" href="mm.html" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="docsearch:language" content="None">
    

    <!-- Google Analytics -->
    
  </head>
  <body data-spy="scroll" data-target="#bd-toc-nav" data-offset="60">
<!-- Checkboxes to toggle the left sidebar -->
<input type="checkbox" class="sidebar-toggle" name="__navigation" id="__navigation" aria-label="Toggle navigation sidebar">
<label class="overlay overlay-navbar" for="__navigation">
    <div class="visually-hidden">Toggle navigation sidebar</div>
</label>
<!-- Checkboxes to toggle the in-page toc -->
<input type="checkbox" class="sidebar-toggle" name="__page-toc" id="__page-toc" aria-label="Toggle in-page Table of Contents">
<label class="overlay overlay-pagetoc" for="__page-toc">
    <div class="visually-hidden">Toggle in-page Table of Contents</div>
</label>
<!-- Headers at the top -->
<div class="announcement header-item noprint"></div>
<div class="header header-item noprint"></div>

    
    <div class="container-fluid" id="banner"></div>

    

    <div class="container-xl">
      <div class="row">
          
<!-- Sidebar -->
<div class="bd-sidebar noprint" id="site-navigation">
    <div class="bd-sidebar__content">
        <div class="bd-sidebar__top"><div class="navbar-brand-box">
    <a class="navbar-brand text-wrap" href="../index.html">
      
        <!-- `logo` is deprecated in Sphinx 4.0, so remove this when we stop supporting 3 -->
        
      
      
      <img src="../_static/logo.png" class="logo" alt="logo">
      
      
      <h1 class="site-logo" id="site-title">Introduction to Operating Systems</h1>
      
    </a>
</div><form class="bd-search d-flex align-items-center" action="../search.html" method="get">
  <i class="icon fas fa-search"></i>
  <input type="search" class="form-control" name="q" id="search-input" placeholder="Search this book..." aria-label="Search this book..." autocomplete="off" >
</form><nav class="bd-links" id="bd-docs-nav" aria-label="Main">
    <div class="bd-toc-item active">
        
        <ul class="nav bd-sidenav bd-sidenav__home-link">
            <li class="toctree-l1">
                <a class="reference internal" href="../intro/pref.html">
                    Preface
                </a>
            </li>
        </ul>
        <p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Getting started
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../intro/intro.html">
   1. Introduction
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../intro/purpose.html">
   2. Purpose of operating systems
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../intro/structure.html">
   3. Operating System Structure &amp; Unix/Linux
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../intro/services.html">
   4. Operating System Services
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../intro/tools.html">
   6. Tools
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../intro/peter-other.html">
   7. Other stuff from peter to integrate
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Scheduling
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../scheduling/scheduling.html">
   10. Processor Scheduling
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Memory Management
 </span>
</p>
<ul class="current nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="intro.html">
   11. Introduction
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="virt-seg.html">
   12. Segmentation
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="virt-paging.html">
   13. Paging
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="page-tables.html">
   14. Page Tables
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="reclamation.html">
   15. Memory reclaiming algorithms.
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="buffer-cache.html">
   16. Page Sizes
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="pagefaults.html">
   17. Page Faults
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="misc.html">
   18. Conclusion
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="realworld.html">
   19. Memory management in the real world
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="concl.html">
   20. Other Stuff
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="mm.html">
   21. EVERYTHING BELOW HERE IS CRAP
  </a>
 </li>
 <li class="toctree-l1 current active">
  <a class="current reference internal" href="#">
   23. Overview of MM
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="peter-mm.html">
   24. Peter’s Virtual Memory chapter
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  File Systems
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../fs/intro.html">
   25. Introduction
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../fs/interface.html">
   26. Interface
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../fs/disklayout.html">
   27. File System Layout
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../fs/kernelimp.html">
   28. Kernel implementation
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Concurrency
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../sync/sync.html">
   29. Intro Concurrency Synchronization and Deadlock
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../sync/sharing.html">
   30. Cooperating Processes
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../sync/locking.html">
   31. Synchronization Primitives
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../sync/deadlock.html">
   32. Deadlocks
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../sync/hardware_challenges.html">
   33. Challenges of Modern Hardware
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../sync/linux_locking.html">
   34. Locking in the Linux Kernel
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../sync/peter-syncro.html">
   35. Synchronization – Safety &amp; Sequencing - FROM PETER’s BOOK
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Other Topics
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../misc/OtherInro.html">
   36. Overview of other topics
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../sec/sec.html">
   37. Security
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../virt/virt.html">
   39. Virtualization and Cloud computing
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../intro/other.html">
   41. Other OS structures
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../devices/block-dev.html">
   42. I/O, Drivers, and DMA {#chap:blockdevs}
  </a>
 </li>
</ul>
<p aria-level="2" class="caption" role="heading">
 <span class="caption-text">
  Appendices
 </span>
</p>
<ul class="nav bd-sidenav">
 <li class="toctree-l1">
  <a class="reference internal" href="../contributing/Contributing.html">
   43. Contributing
  </a>
 </li>
 <li class="toctree-l1">
  <a class="reference internal" href="../misc/bib.html">
   44. Bibliography
  </a>
 </li>
</ul>

    </div>
</nav></div>
        <div class="bd-sidebar__bottom">
             <!-- To handle the deprecated key -->
            
            <div class="navbar_extra_footer">
            Powered by <a href="https://jupyterbook.org">Jupyter Book</a>
            </div>
            
        </div>
    </div>
    <div id="rtd-footer-container"></div>
</div>


          


          
<!-- A tiny helper pixel to detect if we've scrolled -->
<div class="sbt-scroll-pixel-helper"></div>
<!-- Main content -->
<div class="col py-0 content-container">
    
    <div class="header-article row sticky-top noprint">
        



<div class="col py-1 d-flex header-article-main">
    <div class="header-article__left">
        
        <label for="__navigation"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="right"
title="Toggle navigation"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-bars"></i>
  </span>

</label>

        
    </div>
    <div class="header-article__right">
<div class="menu-dropdown menu-dropdown-launch-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Launch interactive content">
      <i class="fas fa-rocket"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://mybinder.org/v2/gh/okrieg/openos/main?urlpath=lab/tree/content/mm/Overview.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Launch on Binder"
>
  

<span class="headerbtn__icon-container">
  
    <img src="../_static/images/logo_binder.svg">
  </span>
<span class="headerbtn__text-container">Binder</span>
</a>

      </li>
      
      <li>
        <a href="https://jupyterhub-redhat-ods-applications.apps.buaws-dev.idu6.p1.openshiftapps.com/hub/user-redirect/git-pull?repo=https%3A//github.com/okrieg/openos&urlpath=lab/tree/openos/content/mm/Overview.ipynb&branch=main"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Launch on JupyterHub"
>
  

<span class="headerbtn__icon-container">
  
    <img src="../_static/images/logo_jupyterhub.svg">
  </span>
<span class="headerbtn__text-container">JupyterHub</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

<button onclick="toggleFullScreen()"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="bottom"
title="Fullscreen mode"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-expand"></i>
  </span>

</button>

<div class="menu-dropdown menu-dropdown-repository-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Source repositories">
      <i class="fab fa-github"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="https://github.com/okrieg/openos"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Source repository"
>
  

<span class="headerbtn__icon-container">
  <i class="fab fa-github"></i>
  </span>
<span class="headerbtn__text-container">repository</span>
</a>

      </li>
      
      <li>
        <a href="https://github.com/okrieg/openos/issues/new?title=Issue%20on%20page%20%2Fmm/Overview.html&body=Your%20issue%20content%20here."
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Open an issue"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-lightbulb"></i>
  </span>
<span class="headerbtn__text-container">open issue</span>
</a>

      </li>
      
      <li>
        <a href="https://github.com/okrieg/openos/edit/main/content/mm/Overview.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Edit this page"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-pencil-alt"></i>
  </span>
<span class="headerbtn__text-container">suggest edit</span>
</a>

      </li>
      
    </ul>
  </div>
</div>

<div class="menu-dropdown menu-dropdown-download-buttons">
  <button class="headerbtn menu-dropdown__trigger"
      aria-label="Download this page">
      <i class="fas fa-download"></i>
  </button>
  <div class="menu-dropdown__content">
    <ul>
      <li>
        <a href="../_sources/mm/Overview.ipynb"
   class="headerbtn"
   data-toggle="tooltip"
data-placement="left"
title="Download source file"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file"></i>
  </span>
<span class="headerbtn__text-container">.ipynb</span>
</a>

      </li>
      
      <li>
        
<button onclick="printPdf(this)"
  class="headerbtn"
  data-toggle="tooltip"
data-placement="left"
title="Print to PDF"
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-file-pdf"></i>
  </span>
<span class="headerbtn__text-container">.pdf</span>
</button>

      </li>
      
    </ul>
  </div>
</div>
<label for="__page-toc"
  class="headerbtn headerbtn-page-toc"
  
>
  

<span class="headerbtn__icon-container">
  <i class="fas fa-list"></i>
  </span>

</label>

    </div>
</div>

<!-- Table of contents -->
<div class="col-md-3 bd-toc show noprint">
    <div class="tocsection onthispage pt-5 pb-3">
        <i class="fas fa-list"></i> Contents
    </div>
    <nav id="bd-toc-nav" aria-label="Page">
        <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#simple-physical-memory-management">
   23.1. Simple physical memory management.
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#sharing-one-physical-address-space">
     23.1.1. Sharing one physical address space.
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#relocating-programs">
     23.1.2. Relocating programs.
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#virtual-memory-management">
   23.2. Virtual memory management
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#segmentation">
   23.3. Segmentation.
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#single-segments-per-address-space">
     23.3.1. Single segments per address space
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#multiple-segments-per-address-space">
     23.3.2. Multiple segments per address space.
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#private-versus-global-segments">
     23.3.3. Private versus Global segments.
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#compaction">
       23.3.3.1. Compaction.
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#limitations-of-segmentation">
       23.3.3.2. Limitations of segmentation.
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#paging">
     23.3.4. Paging
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#virtual-pages-and-page-frames">
       23.3.4.1. Virtual pages and page frames.
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#page-tables">
       23.3.4.2. Page tables.
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#virtual-address-spaces-larger-than-ram">
       23.3.4.3. Virtual address spaces larger than RAM.
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#management-of-physical-memory">
       23.3.4.4. Management of physical memory.
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#management-of-virtual-memory">
       23.3.4.5. Management of virtual memory.
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#mappings">
       23.3.4.6. Mappings
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#over-committing-physical-memory">
       23.3.4.7. Over committing physical memory.
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#paging-and-swapping">
       23.3.4.8. Paging and Swapping.
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>

    </nav>
</div>
    </div>
    <div class="article row">
        <div class="col pl-md-3 pl-lg-5 content-container">
            <!-- Table of contents that is only displayed when printing the page -->
            <div id="jb-print-docs-body" class="onlyprint">
                <h1>Overview of MM</h1>
                <!-- Table of contents -->
                <div id="print-main-content">
                    <div id="jb-print-toc">
                        
                        <div>
                            <h2> Contents </h2>
                        </div>
                        <nav aria-label="Page">
                            <ul class="visible nav section-nav flex-column">
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#simple-physical-memory-management">
   23.1. Simple physical memory management.
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#sharing-one-physical-address-space">
     23.1.1. Sharing one physical address space.
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#relocating-programs">
     23.1.2. Relocating programs.
    </a>
   </li>
  </ul>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#virtual-memory-management">
   23.2. Virtual memory management
  </a>
 </li>
 <li class="toc-h2 nav-item toc-entry">
  <a class="reference internal nav-link" href="#segmentation">
   23.3. Segmentation.
  </a>
  <ul class="nav section-nav flex-column">
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#single-segments-per-address-space">
     23.3.1. Single segments per address space
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#multiple-segments-per-address-space">
     23.3.2. Multiple segments per address space.
    </a>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#private-versus-global-segments">
     23.3.3. Private versus Global segments.
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#compaction">
       23.3.3.1. Compaction.
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#limitations-of-segmentation">
       23.3.3.2. Limitations of segmentation.
      </a>
     </li>
    </ul>
   </li>
   <li class="toc-h3 nav-item toc-entry">
    <a class="reference internal nav-link" href="#paging">
     23.3.4. Paging
    </a>
    <ul class="nav section-nav flex-column">
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#virtual-pages-and-page-frames">
       23.3.4.1. Virtual pages and page frames.
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#page-tables">
       23.3.4.2. Page tables.
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#virtual-address-spaces-larger-than-ram">
       23.3.4.3. Virtual address spaces larger than RAM.
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#management-of-physical-memory">
       23.3.4.4. Management of physical memory.
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#management-of-virtual-memory">
       23.3.4.5. Management of virtual memory.
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#mappings">
       23.3.4.6. Mappings
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#over-committing-physical-memory">
       23.3.4.7. Over committing physical memory.
      </a>
     </li>
     <li class="toc-h4 nav-item toc-entry">
      <a class="reference internal nav-link" href="#paging-and-swapping">
       23.3.4.8. Paging and Swapping.
      </a>
     </li>
    </ul>
   </li>
  </ul>
 </li>
</ul>

                        </nav>
                    </div>
                </div>
            </div>
            <main id="main-content" role="main">
                
              <div>
                
  <section class="tex2jax_ignore mathjax_ignore" id="overview-of-mm">
<span id="cont-mm-overview"></span><h1><span class="section-number">23. </span>Overview of MM<a class="headerlink" href="#overview-of-mm" title="Permalink to this headline">#</a></h1>
<p>Today the dominant type of memory management that is widely assumed and used is paged virtual memory management.  In this chapter we describe the evolution of memory management from <a class="reference internal" href="#cont-mm-overview-simple"><span class="std std-ref">simple</span></a> physical, to segmented virtual, to today’s paged virtual systems.</p>
<figure class="align-default" id="mem-pys-mem-fig">
<a class="reference internal image-reference" href="../_images/phys-mem.png"><img alt="../_images/phys-mem.png" src="../_images/phys-mem.png" style="width: 80%;" /></a>
<figcaption>
<p><span class="caption-number">Fig. 23.1 </span><span class="caption-text">Some description of this figure.</span><a class="headerlink" href="#mem-pys-mem-fig" title="Permalink to this image">#</a></p>
</figcaption>
</figure>
<section id="simple-physical-memory-management">
<span id="cont-mm-overview-simple"></span><h2><span class="section-number">23.1. </span>Simple physical memory management.<a class="headerlink" href="#simple-physical-memory-management" title="Permalink to this headline">#</a></h2>
<p>From a hardware perspective, the simplest memory management model is to have processes just use the physical address space; where instructions executed on the processor directly reference physical memory addresses.  For example, if the application wants to load a register, it would issue the instruction directly indicating the physical memory address.  Similarly, every branch and procedure call directly uses physical memory addresses.</p>
<p>As shown in <a class="reference internal" href="#mem-pys-mem-fig"><span class="std std-numref">Fig. 23.1</span></a>.</p>
<p>Early in the development of computer hardware and operating systems physical memory management was used.  While this is very primitive, physical memory management is still used in simple embedded systems.</p>
<p>Physical memory management two major problems: 1) there is no protection between processes, and 2) there is the need for relocation.</p>
<p>without any translation. This implies processes sharing that physical address space are randomly scattered around within it.  Each process also must deal with different addresses and there is no protection between those processes.</p>
<section id="sharing-one-physical-address-space">
<h3><span class="section-number">23.1.1. </span>Sharing one physical address space.<a class="headerlink" href="#sharing-one-physical-address-space" title="Permalink to this headline">#</a></h3>
<p>Users were typically limited to trusted colleges and few users shared the computer at the same time which was good because sharing one physical address space offers no protection between users, one program running can simply read and write all the memory regardless of who was using it.  Over time the quantity of memory expanded allowing more users to run programs on the computer at the same time.  In addition to a lack of protection sharing a single physical address space requires every program to deal with different physical addresses since its not know exactly where they will be loaded and run.  Each time a program is run its likely to loaded and run at a different address.  Dealing with this imposes a significant burden on basic programming.  To eliminate this burden operating system designers developed a relocation technique that corrected all the physical addresses when a program was loaded as a specific address.</p>
</section>
<section id="relocating-programs">
<h3><span class="section-number">23.1.2. </span>Relocating programs.<a class="headerlink" href="#relocating-programs" title="Permalink to this headline">#</a></h3>
<p>When a program is compiled and linked into object code the address at which the program will run must be known so that branch destinations can be established.  When the program is loaded into memory it must be loaded at the correct address or the program will branch to the wrong locations.  Since more than one program can run at the same time there is no guarantee that the program will be loaded and run at the address it was linked to run.  For this reason programs are usually linked as relocatable.  Relocatable programs have a table of all addresses within the program image that must be changed if it is loaded at a different address than it was linked before it can be run.   This is how more that one program can be run at the same time in a system that only supports physical memory management.</p>
</section>
</section>
<section id="virtual-memory-management">
<h2><span class="section-number">23.2. </span>Virtual memory management<a class="headerlink" href="#virtual-memory-management" title="Permalink to this headline">#</a></h2>
<p>As discussed above physical memory management model has significant drawbacks, lack of protection and mandatory relocation being the most significant.  For this reason memory management subsystem has evolved over time give each process its own private address space known as a virtual address space.  The virtual address space for each process looks identical, that is starting at zero going up to some limit and provides protection from other virtual address spaces so that one process can not corrupt any other processes.</p>
</section>
<section id="segmentation">
<h2><span class="section-number">23.3. </span>Segmentation.<a class="headerlink" href="#segmentation" title="Permalink to this headline">#</a></h2>
<p>In the simplest form of segmentation the hardware provides 2 registers that are loaded each time a process acquire the CPU, a base register and a limit register.  For a given process the base register contains the physical address that the program was loaded at and the limit register contains the size of the program that was loaded into memory.  Every process has a virtual address space starting at zero and a size determined by the actual program size that the process is running.  The process specific base and limit registers which are loaded every time a process acquires the CPU establishes the bounds of the virtual address space for every process.  For each and every memory reference the hardware adds the virtual address to the base register to determine a physical address and insures that the physical address is between the base register and base register plus the limit register.  If it is outside those bounds the program is terminated with an illegal virtual memory reference error.  Segmentation solves both the lack of protection and the mandatory relocation requirements of physical addressing.  Segmentation has little or no performance overhead because the hardware performs the virtual to physical translation or the addition of the virtual address and the base register to determine every physical address.</p>
<section id="single-segments-per-address-space">
<h3><span class="section-number">23.3.1. </span>Single segments per address space<a class="headerlink" href="#single-segments-per-address-space" title="Permalink to this headline">#</a></h3>
<p>So far we discussed a segmentation implementation that provides one base register and one limit register in hardware and one of each of those process specific values that gets loaded into those registers when context switching to a given process.  Since there is only one of each register, the entire process virtual address space must be physically contiguous and all text, data and stack must be within that single memory region.  While this is a huge improvement over a physical memory model it limits the size of the virtual address space to being static and not expandable.  There is no way to dynamically increase the size of the text, data or stack regions of a process at run-time, everything must be allocated in advance.  This requires allocating physical memory that might never be used.</p>
</section>
<section id="multiple-segments-per-address-space">
<h3><span class="section-number">23.3.2. </span>Multiple segments per address space.<a class="headerlink" href="#multiple-segments-per-address-space" title="Permalink to this headline">#</a></h3>
<p>As mentioned earlier a single base and limit segment register implies that an entire process virtual address space is a one physically contiguous region of physical memory mapped into one virtually contiguous virtual region of virtual memory.  This means that the text, data and stack regions must be packed tightly together in both physical and virtual memory unless we are willing to waste both physical and virtual memory.  Also, with only one segment register its not possible to offer different types of protections for the various regions of the virtual address space.  In other words all of virtual memory must be readable, writable and executable since data must be both readable and writable and text must be executable.  It would be nice to prevent data regions from being executable and text regions from being readable and writable for security and debug optimizations.</p>
<p>This can be achieved by the hardware implementing multiple segment and limit registers with only specified permissions for text, data and stack regions and having the operating system use those registers when context switching to a process.  When mapping the text into a virtual region the operating system can specify an execute only region that does not have to be adjacent to other non-executable regions.  When mapping data into virtual memory the operating system can specify read/write only thereby preventing execution of data regions.  Finally the stack can also be non-executable but also the operating system can move the virtual memory stack region away from any other region making it easier to debug common programming problems like stack overflows.  Finally multiple segment registers eliminates the necessity for the text, data and stack regions to be physically contiguous.  This allows a program to be split up into multiple smaller regions both physically and virtually making it much easier to hold more programs in physical memory at the same time.</p>
</section>
<section id="private-versus-global-segments">
<h3><span class="section-number">23.3.3. </span>Private versus Global segments.<a class="headerlink" href="#private-versus-global-segments" title="Permalink to this headline">#</a></h3>
<p>Every process virtual address space consists of 2 types of regions, Private and Global.  The private regions for a process are the program specific text, data and stack regions that the process is running.  The global regions include the operating system that is and must be mapped into every process address space.  As we discussed earlier in this course the operating system consists of all the software that executes on behalf of the currently running program as well as basic system overhead that runs on behalf of the system.  This includes all the system calls the operating system supports.  Since every process must map the operating system kernel it is shared between every running process rather than each process containing a separate copy.  The global segment registers are used to map the shared kernel text, data and kernel stack area in every process and at the same virtual addresses.  When a context switch occurs only the private segments registers are changed for the newly running process, there is no need to change the global segment registers since they are identical for every process.</p>
<section id="compaction">
<h4><span class="section-number">23.3.3.1. </span>Compaction.<a class="headerlink" href="#compaction" title="Permalink to this headline">#</a></h4>
<p>When a new process is created and a program runs the kernel reads the program text, data and stack memory into the available or free physical memory locations.  From there the private segment registers are use to map that physical memory into the private virtual address space of the process, allowing the process to run the program.  When a process exits, the physical memory regions that the process consumed is made available or freed onto a physical memory free list.  Over time as processes are created, run and exit the physical memory becomes more and more fragmented.  After a while as processes come and go its likely that the sum of available physical memory is large enough to satisfy a request but there is no physically contiguous free memory region large enough to hold the request.  When this happens the operating system must move or coalesce the used memory regions together thereby creating a large contiguous available or free region.  Now one or more requests can be satisfied.  This is all made possible because the base registers of the processes that map these moved regions can be updated to the new locations of the physical memory and because the operating system has the ability to relocate programs in physical memory as we discussed in the physical memory management model.</p>
</section>
<section id="limitations-of-segmentation">
<h4><span class="section-number">23.3.3.2. </span>Limitations of segmentation.<a class="headerlink" href="#limitations-of-segmentation" title="Permalink to this headline">#</a></h4>
<p>Segmentation, especially with multiple segment registers along with private and global segment registers provides a huge benefit over a physical memory management model.  We can now support many processes running at the same time with protection between processes and even protection within a process.  However that is still one major weakness with segmentation, the virtual address size can never exceed the physical address size with segmentation.  It would be very convenient to be able to allocate a very large sparse region of virtual memory and only actually use a small subset of it.  Imagine allocating an array of fixed size records for every possible student at Boston University and indexing that array by the student’s social security number.  There are 10^9 or 1 Billion social security numbers but only several thousand students.  Such a large sparse array could not be implemented with segmentation unless the system actually had all the necessary physical memory for every possible social security number.  Imagine being able to map millions of files in a virtual address space on a system that didn’t have all that much physical memory.</p>
</section>
</section>
<section id="paging">
<h3><span class="section-number">23.3.4. </span>Paging<a class="headerlink" href="#paging" title="Permalink to this headline">#</a></h3>
<p>As mentioned earlier, a major limitation of segmentation is not being able to support a virtual address space which is larger than the amount of physical memory on a system.  In order to do this we would have to be able to have portions of the virtual address space that are not backed by RAM and other portions that are.  This is not possible with segmentation because we would always need part of the text, data and stack sections in physical memory and segmentation requires the whole segment in physical memory.  Also segments will always be different sizes, the data section is likely to be much larger than the text section which is likely to be much larger than the stack section.  So, what we really need is a virtual memory model that only requires a random number of small fixed size portions of physical memory to be mapped in virtual memory at a time.</p>
<p>To satisfy these requirements modern systems implement a virtual memory model known as paging.  With paging virtual memory is divide into small fixed size “pages” and physical memory is divided into same fixed size “page frames”.  For example the 32-bit Intel x86 system has a 4GB(2^32) virtual memory size, a 4KB(2^12) virtual page size and a 4KB(2^12) physical page size.  in this example each process has a private 4GB(2^32) byte virtual address space divided into 1048576(2^32/2^12 = 2^20) 4KB(2^12) “pages”.  The system itself manages physical memory or RAM in a variety of different sizes, typically from 1GB(2^30) up to 4GB(2^32) on the x86 and it is split up into 262144(2^30/2^12 = 2^18) for 1GB of RAM up to 1048576(2^32/2^12 = 2^20) “page frames” of physical memory for 4GB of RAM.</p>
<section id="virtual-pages-and-page-frames">
<h4><span class="section-number">23.3.4.1. </span>Virtual pages and page frames.<a class="headerlink" href="#virtual-pages-and-page-frames" title="Permalink to this headline">#</a></h4>
<p>As mentioned above both the virtual memory or virtual address space and the physical memory consists of small fixed size regions called pages and page frames respectively.  Pages and page frames must be the same size so that page frames can be mapped into pages and size of pages and page frames are always a power-of-two.  Also as mentioned earlier the x86 and x86_64 Intel systems have a 4KB page size.  Both the virtual address space and the physical memory can be envisioned as an array of pages and page frames respectively.  The virtual address space is always a power-of-two in size but the physical memory does no have to be.  For example the x86 system described earlier is a 32-bit system therefore the size of the process’s virtual address space is 2^32 or 4GB, or an array of 1M 4096-byte pages.  The physical memory size can be a power-of-two but it does no have to be.  You could install 1GB of RAM which is 256K 4096-byte page frames but you could also install 1.5GB of RAM which is 384K 4066-byte page frames.</p>
<p>The virtual address size(Vsize) is equal to the page size(Psize) multiplied by the number of pages(Npages) or Vsize = Psize X Npages and all 3 must be powers-of-two.  Calculating the Vsize, Psize or Npages is simple if you know the other 2 especially since they are always powers-of-two.  For example a system that has a 1GB Vsize and 1KB Psize has 1M Npages(1GB Vsize/1KB Psize = 1M Npages) and since they must all be powers-of-two (2^30 - 2^10 = 2^20 which is 1M pages).</p>
</section>
<section id="page-tables">
<h4><span class="section-number">23.3.4.2. </span>Page tables.<a class="headerlink" href="#page-tables" title="Permalink to this headline">#</a></h4>
<p>The data structure that contains the virtual page to physical page frame mapping in a paging system is the page table. There is one page table for each process running in the system.  The page table is an array of page table entries.  There is one page table entry for each page in the virtual address space.  The page table entry is either NULL if no mapping exists or its a page frame number if a mapping does exist.  The number of page table entries in a page table is equal to the number of virtual pages in the process address space.  The Nth entry in the page table describes the virtual to physical mapping for the Nth virtual page in the address space.  In other words pagetable[0] describes the mapping for virtual page 0, pagetable[1] describes the mapping for virtual page 1…pagetable[N] describes the mapping for virtual page N.  Each time the CPU references a virtual address the hardware uses the virtual address to index into the page table and extract the page table entry.  If that page table entry contains a valid page frame number the hardware references the associated physical page.  This is known as virtual to physical translation and while there is some performance consequence the hardware is optimized to process the page table.  If that page table entry is NULL a page fault occurs and the operating system resolves it, much more on this later.</p>
</section>
<section id="virtual-address-spaces-larger-than-ram">
<h4><span class="section-number">23.3.4.3. </span>Virtual address spaces larger than RAM.<a class="headerlink" href="#virtual-address-spaces-larger-than-ram" title="Permalink to this headline">#</a></h4>
<p>As mentioned earlier the main weakness in segmentation is not being able to have a larger virtual address space size than the physical memory size.  Paging solves that problem is a profound way, not only can a single virtual address space be orders of magnitude larger than the physical memory size, there can practically be an unlimited number of processes or virtual addresses actively running at the same time on a paging system.  Its the page table that makes this possible.</p>
<p>In the x86 example each process has a 4GB Vsize which is 1M virtual pages for each process.  If that x86 system is currently running 1000 processes there are 1G virtual pages on the whole system.  Since the virtual address space on an x86 paging system consists of 1M 4KB pages only a small subset of those virtual pages must map physical pages at any one time.  As long as that subset size is smaller than the number of physical pages that process can run.  If there are 1000 processes that need to run, they can all run as long as the sum of all those subset sizes are smaller than the number of physical pages.</p>
<p>When a child process is created its virtual address is created as well.  Typically that virtual address space is a shared copy of the parent’s virtual address space so there is little or no additional physical memory required to get that child process to start running.  Alternately in some operating systems the virtual address space of a newly created process can be empty(windows for example).  This also has little or no additional physical memory requirement to get that process running.  As that process starts running it references virtual pages that are either shared with the parent or have no physical memory mapped.  If there is no physical memory mapped at that virtual address this results in what is know as a page fault(more on this later)  The page fault handling routine allocates a page frame of physical memory and maps it into the virtual page that caused the page fault.  Once the process resumes execution the faulting virtual address now has a page frame mapped into it so the process continues running successfully, once again, much more on page faults later.</p>
</section>
<section id="management-of-physical-memory">
<h4><span class="section-number">23.3.4.4. </span>Management of physical memory.<a class="headerlink" href="#management-of-physical-memory" title="Permalink to this headline">#</a></h4>
<p>As we mentioned earlier the physical memory is arranged into fixed size page frames, 4096 bytes or 4KB each is typical.  The kernel maintains a data structure known as the struct_page for each page frame of physical memory.  The kernel also maintains an array of struct_pages called the page_array.
In the page_array the Nth struct_page in the page_array is used to represent and monitor the Nth page frame of physical memory.  In other words the struct_page at page_array[0] represent the page frame at physical address 0, the struct_page at page_array[1] represent the page frame at physical address 4096, the struct_page at page_array[2] represent the page frame at physical address 8192 and so on.</p>
<p>The kernel also maintains a free list of page_structs representing free pages.  When the kernel boots up every page of memory that is not being used is freed or inserted on the free list.  As memory is needed by the kernel for various reasons(handling page faults for example), pages is removed from the free list or “allocated” and used.  When memory is no longer being used(when a process exits for example), pages are inserted back on the free list or “freed”.  As memory is allocated and freed the kernel maintains an accurate free page list count.</p>
</section>
<section id="management-of-virtual-memory">
<h4><span class="section-number">23.3.4.5. </span>Management of virtual memory.<a class="headerlink" href="#management-of-virtual-memory" title="Permalink to this headline">#</a></h4>
<p>Each process had its own private virtual address space which is a large fixed size based on the number of hardware address bit, for example the x86 32-bit system has a 4GB or 2^32 virtual address space for every process.  In order to maintain this virtual address space the kernel allocates a page table that maintains the mapping for every virtual page.  For example the x86 32-bit system has 1M virtual pages so a 1M entry page table is allocated when a process is created.</p>
<p>The kernel also maintains a list of virtual_memory_area data structures or VMAs representing areas within the virtual address space that are valid.  The VMA structure must include the beginning and ending virtual addresses and protection for the region it represents.  For example when a program is mapped in virtual address space to run separate VMAs will be allocated and added to the list for the text, data and stack sections with appropriate beginning addresses, ending addresses and protections.  The kernel will only allow virtual memory references to locations within a VMA, any memory references outside of a region described by a VMA are considered illegal and will cause the program to terminate.</p>
<p>While it is possible for a program to use the entire virtual address space of a process its not very common.  Its very common for a virtual address space to be very sparse and out of millions of potential virtual pages to have a few hundred to a few thousand valid ones described by the VMAs.  When a process is created the virtual address space is very sparse.  As the program runs it allocates more virtual memory so more of its virtual address space becomes valid.</p>
</section>
<section id="mappings">
<h4><span class="section-number">23.3.4.6. </span>Mappings<a class="headerlink" href="#mappings" title="Permalink to this headline">#</a></h4>
<p>There are 2 basic types of virtual memory regions; anonymous and file-backed.  Anonymous virtual memory is any virtual memory that is not backed by a file on some storage device, this included stacks, heaps, uninitialized data(BSS), etc.  File-backed virtual memory is simply the contents of a portion of a file on some storage device.  The creation of virtual memory regions validates a region or range of the virtual address space and allows for page frames of physical memory to be mapped into virtual pages.  The validating on or more region of virtual memory is done by a program making memory management specific system calls; mmap() brk, sbrk for example.  The mapping of page frames into virtual memory is done by the page fault and its associated page fault handler as was described above.</p>
<p>The anonymous memory page fault handler simply validates the virtual address, allocates a page frame of free memory and maps that page frame into the virtual page by making the appropriate page table entry valid.   Once this is done the memory management hardware will translate that virtual address into a physical address as long as the page table entry remains valid.  The file-backed memory page fault handler allocates a page frame of free memory, reads the contents of that file and its offset into that page frame before mapping that page frame into the virtual page by making the appropriate page table entry valid.  Again, once this is done the memory management hardware will translate that virtual address into a physical address as long as the page table entry remains valid.</p>
</section>
<section id="over-committing-physical-memory">
<h4><span class="section-number">23.3.4.7. </span>Over committing physical memory.<a class="headerlink" href="#over-committing-physical-memory" title="Permalink to this headline">#</a></h4>
</section>
<section id="paging-and-swapping">
<h4><span class="section-number">23.3.4.8. </span>Paging and Swapping.<a class="headerlink" href="#paging-and-swapping" title="Permalink to this headline">#</a></h4>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>- Quick overview of what memory manager needs to do
    - compaction 
    - bringing things in, demand paging
        swapping, paging
    - deciding what to kick out - reclamation
    - anonymous memory
    - file backed and caching storage
    - example: look at elf, parts of the program...
</pre></div>
</div>
</section>
</section>
</section>
</section>

    <script type="text/x-thebe-config">
    {
        requestKernel: true,
        binderOptions: {
            repo: "binder-examples/jupyter-stacks-datascience",
            ref: "master",
        },
        codeMirrorConfig: {
            theme: "abcdef",
            mode: "python"
        },
        kernelOptions: {
            kernelName: "python3",
            path: "./mm"
        },
        predefinedOutput: true
    }
    </script>
    <script>kernelName = 'python3'</script>

              </div>
              
            </main>
            <footer class="footer-article noprint">
                
    <!-- Previous / next buttons -->
<div class='prev-next-area'>
    <a class='left-prev' id="prev-link" href="mm.html" title="previous page">
        <i class="fas fa-angle-left"></i>
        <div class="prev-next-info">
            <p class="prev-next-subtitle">previous</p>
            <p class="prev-next-title"><span class="section-number">21. </span>EVERYTHING BELOW HERE IS CRAP</p>
        </div>
    </a>
    <a class='right-next' id="next-link" href="peter-mm.html" title="next page">
    <div class="prev-next-info">
        <p class="prev-next-subtitle">next</p>
        <p class="prev-next-title"><span class="section-number">24. </span>Peter’s Virtual Memory chapter</p>
    </div>
    <i class="fas fa-angle-right"></i>
    </a>
</div>
            </footer>
        </div>
    </div>
    <div class="footer-content row">
        <footer class="col footer"><p>
  
    By Angela Demke Brown, Orran Krieger & Larry Woodman<br/>
  
      &copy; Copyright 2022.<br/>
</p>
        </footer>
    </div>
    
</div>


      </div>
    </div>
  
  <!-- Scripts loaded after <body> so the DOM is not blocked -->
  <script src="../_static/scripts/pydata-sphinx-theme.js?digest=1999514e3f237ded88cf"></script>


  </body>
</html>