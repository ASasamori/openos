Traceback (most recent call last):
  File "/opt/conda/lib/python3.10/site-packages/jupyter_cache/executors/utils.py", line 51, in single_nb_execution
    executenb(
  File "/opt/conda/lib/python3.10/site-packages/nbclient/client.py", line 1204, in execute
    return NotebookClient(nb=nb, resources=resources, km=km, **kwargs).execute()
  File "/opt/conda/lib/python3.10/site-packages/nbclient/util.py", line 84, in wrapped
    return just_run(coro(*args, **kwargs))
  File "/opt/conda/lib/python3.10/site-packages/nbclient/util.py", line 62, in just_run
    return loop.run_until_complete(coro)
  File "/opt/conda/lib/python3.10/asyncio/base_events.py", line 646, in run_until_complete
    return future.result()
  File "/opt/conda/lib/python3.10/site-packages/nbclient/client.py", line 663, in async_execute
    await self.async_execute_cell(
  File "/opt/conda/lib/python3.10/site-packages/nbclient/client.py", line 965, in async_execute_cell
    await self._check_raise_for_error(cell, cell_index, exec_reply)
  File "/opt/conda/lib/python3.10/site-packages/nbclient/client.py", line 862, in _check_raise_for_error
    raise CellExecutionError.from_cell_and_msg(cell, exec_reply_content)
nbclient.exceptions.CellExecutionError: An error occurred while executing the following cell:
------------------
The process abstraction is designed to give the illusion that a program executes on its own
private, isolated (virtual) machine. The OS scheduling mechanism hides the fact that the
physical CPU is, in fact, shared by multiple processes. From the perspective of any given 
process, it appears as though its instructions execute one after the other, in the order 
that they appear in the program, on a dedicated CPU, without interruption or interference 
by the execution of other processes. The process also has sole access to a virtual address
space, where it can store and operate on its data -- there is no concern about access to
the process's memory from other processes, or that the process may inadvertently access 
memory that does not belong to it.

But what if multiple processes need to work together to solve a problem? How can they
cooperate if they are completely isolated from each other?

Why use multiple processes to solve a problem? 
    1. Unix command pipelines - each program is designed to do one thing well, output
    from one becomes the input to the next.
    1. Logical concurrency - structure service with multiple processes, each handles a 
    particular task, OS scheduler ensures all tasks make progress. e.g., bank server with 
    input handling process, withdrawal handling process, deposit handling process. 
    1. Parallel execution - use multiple physical compute cores to complete a task faster,
    e.g., sorting very large set of values, each process sorts a portion of the input,
    then merge the results together. 
    
    
------------------

[0;36m  Input [0;32mIn [1][0;36m[0m
[0;31m    the process's memory from other processes, or that the process may inadvertently access[0m
[0m               ^[0m
[0;31mSyntaxError[0m[0;31m:[0m unterminated string literal (detected at line 8)

SyntaxError: unterminated string literal (detected at line 8) (1545106716.py, line 8)

